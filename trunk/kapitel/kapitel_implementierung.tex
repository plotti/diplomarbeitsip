\chapter{Implementierung}

Bei der Implementierung bestand die Herausforderung darin eine virtuelle 3D-Welt zu erzeugen und sie mit VoIP Funktionalität zu kombinieren. Dabei sollten die einzelnen Komponenten so gewählt werden, dass die in Kapitel 3 präsentierten Verbesserungsvorschläge für eine bessere Sprachkommunikation tatsächlich praktisch umgesetzt werden können. Außerdem sollten die gewählten Komponenten auch die in Kapitel 6 gewählte Architektur unterstützen.
 
\section{3D Umgebung}
Da die Entwicklung eines realistisches Spieles weit über das Thema der Arbeit hinaus geht, und diese Aufgabe normalerweise von ganzen Teams über mehrere Monate oder Jahre bewältigt wird, sollen nach Möglichkeit bestehende Komponenten eingesetzt werden.

Deswegen habe ich mich entschlossen bestehende Frameworks zu nutzen. Diese sollten dazu eingesetzt werden einen Prototypen zu erstellen, in dem ein Avatar in einer möglichst realistischen 3D Umgebung gesteuert werden kann. 

Viele der bestehenden Frameworks für 3D orientierte Spiele basieren meist auf Eigenenwicklungen großer Softwarestudios wie \textit{Idsoftware} \footnote{IdSoftware, Version 21.03.2008, http://www.idsoftware.com/} oder \textit{Epic Games} \footnote{Epic Games, Version 21.03.2008, http://www.unrealtechnology.com}. Diese setzten Standards, indem sie den Quellcode ihrer bisher erfolgreichsten Spiele wie z.B.\textit{Quake II}, \textit{Quake III} oder \textit{Unreal I} öffentlich anboten. Da meist mit dem Aufkommen einer neuen Generation kommerzieller Titel die Entwicklung eines neuen Frameworks mit einher geht, existieren von den Haupvertretern großer Frameworks gleich mehrere Versionen und Derrivate \footnote{Wikipedia, Version: 21.03.2008,  http://en.wikipedia.org/wiki/Quake\_series}. 

Seit einigen Jahren sind auch komplette Neuentwicklungen wie \textit{Sauerbraten} \footnote{W. Oortmerssen, Version 21.03.2008, http://sauerbraten.org} oder \textit{Nexuiz} \footnote{Alientrap, Version 21.03.2008, http://www.alientrap.org/nexuiz/} speziell für 3D-Actionspiele geschrieben worden. Obwohl diese eine opulente Grafik, ausgereifte Spielbalance und durchdachte Steuerung bieten, ist die Modifikation der darunter liegenden Hauptbestandteile schwer. Technische Details der Netzwerk- und Audiokomponenten oder der eigentlichen Spielelogik sind teilweise nicht ausführlich dokumentiert und machen Änderungen sehr mühsam oder sehen diese gar nicht vor. 

\subsection{3D Engines}
Eine Alternative zu reinen Spiele-Engines bieten offene generische 3D-Engines, deren Fokus nicht auf der kompletten Entwicklung eines speziellen Spiels liegt. Stattdessen sollen sie ermöglichen möglichst komfortabel 3D-Grafiken interaktiv darzustellen. Dazu werden meist die Details von Systembibliotheken wie \textit{Direct3D} oder \textit{OpenGL} abstrahiert und dem Entwickler ein Interface angeboten, das auf höheren Abstraktionsklassen basiert. Bekannte Vertreter sind \textit{Ogre3D} \footnote{TheOGRETeam, Version. 22.03.2008,  http://www.ogre3d.org/} oder \textit{Irrlicht} \footnote{N. Gebhardt, Version. 22.03.2008, http://irrlicht.sourceforge.net/}. 

\subsubsection{\textit{Irrlicht}}
\textit{Irrlicht} ist ein einfaches gut dokumentiertes open source Framework das in C++ geschrieben wurde. Alle üblichen 3D Features wie \textit{Collision Detection}, Animationen, \textit{Shading} und Texturen werden sowohl unter \textit{Windows}, \textit{Linux} als auch \textit{Mac OS} unterstützt. Aufgrund der bestehenden Arbeit von Triebel \cite{triebel07g}, war es mir möglich bereits bestehende Konzepte zu verwenden und somit eine schnelle Entwicklung des Prototyps zu gewährleisten.

\subsubsection{\textit{Irrklang}}
Speziell für die Sprachkommunikation musste das 3D-Framework um eine Audio-Engine erweitert werden, die eine gezielte Audioausgabe ermöglicht. Speziell für Irrlicht existiert \textit{IrrKlang} \footnote{N. Gebhardt, Version 22.03.2008, http://www.ambiera.com/irrklang/index.html}, eine einfache plattform-übergreifende Audiobibliothek. Sie unterstützt Audioverarbeitung auf der untersten Ebene, realistisches \textit{3D-Audio-Rendering}, \textit{Multithreading} und kann über \textit{Plugins} erweitert werden. Zusätzlich verfügt sie über eine einfache API, die eine schnelle Einarbeitung und Entwicklung ermöglicht. All diese Gründe waren ausschlaggebend diese Bibliothek zu benutzen. 

\section{VoIP Lösung}

Zwecks der Implementierung einer Sprachkommunikationslösung stehen mehrere Alternativen zur Verfügung: 

\begin{itemize}
	\item Bestehende Drittanbieter Lösungen können abgeändert werden, um den gestellten Ansprüchen zu genügen.
	\item Existierende VoIP Programme können durch Nutzung ihrer API genutzt werden, um während dem Spiel Audioinformationen zu übertragen.
	\item Bestehende Bibliotheken oder \textit{Protokollstapel}, können genutzt werden um eigene VoIP Lösungen zu entwickeln.
\end{itemize}

Bisher werden im Spielebereich fast ausschließlich serverbasierte Drittanbieter Lösungen eingesetzt. Sie alle bieten Unterstützung für effiziente Audiocodecs und besitzen einen vergleichbaren Funktionsumfang. Im privaten VoIP Telefoniebereich werden oft kommerzielle Produkte wie \textit{Skype} eingesetzt. Es existieren kaum offene Sprachkommunikationslösungen. Gleichzeitig existieren viele bestehende offene Protokollstapel, mit denen eigene Lösungen implementiert werden können.

\subsection{Serverbasierte Sprachkommunikationslösungen}
%http://www.tentonhammer.com/index.php?q=node/102

\subsubsection{\textit{Ventrillo}}
%http://www.ventrilo.com/
Die unter Spielern beliebteste Lösung \textit{Ventrillo} \footnote{Flagship Industries, Inc. Programmversion 3.0.1, http://www.ventrilo.com} ist eine serverbasierte proprietäre VoIP Anwendung. Die Software besteht aus einem Server- und Client-Modul, wobei die Clientsoftware frei erhältlich ist, für die Serverkomponente jedoch eine kostenpflichtige Lizenz zu erwerben ist. Benutzer des Ventrillo Clients melden sich vor Beginn des eigentlichen Spieles auf einem der kostenpflichtigen Ventrillo Server an und können dort einen Kanal betreten. Benutzer des gleichen Kanals auf dem gleichen Server können sich gegenseitig hören. Durch das Lizenzmodell ist es nicht möglich im privaten Bereich eigene Server zu betreiben oder die Software nach eigenen Vorstellungen anzupassen. 

\subsubsection{\textit{Teamspeak}}
%http://www.goteamspeak.com
Teamspeak \footnote{TeamSpeak Systems GmbH, Programmversion 2.0.33.7, http://www.goteamspeak.com} ist ebenfalls ein serverbasiertes proprietäres VoIP Programm. Die Software besteht ebenfalls aus Server und Client Komponenten. Benutzer des kostenlosen \textit{Teamspeak} Clients können sich mit dem kostenpflichtigem \textit{TeamSpeak} Server ihrer Wahl verbinden und dort einen Kanal betreten. Benutzer des gleichen Kanals auf dem gleichen Server können gegenseitig gehört werden. Zusätzlich existieren Plugins die es erlauben Kanäle während der Spielesitzung per Tastaturkombination zu wechseln. 


\subsubsection{\textit{Mumble}}
%http://mumble.sourceforge.net
\textit{Mumble} \footnote{Thorvald Natvig,Programmversion 1.1.3, http://mumble.sourceforge.net} ist eine offene serverbasierte VoIP Anwendung, die primär von Computerspielern für Sprachkommunikation genutzt wird. \textit{Mumble} versucht die soziale Komponente der Sprachkommunikation zu betonen, indem es für den Endanwender sehr wenige administrative Elemente besitzt und das Hauptaugenmerk auf der Sprachqualität liegt. Seine Verwendung gleicht den anderen bisher vorgestellten Programmen.

Obwohl die kommerziellen Lösungen bei einer optimalen Konfiguration hunderte von Benutzern unterstützen können und eine gute Sprachqualität bieten haben sie den entscheidenden Nachteil, dass sie nicht modifizierbar sind, die Serverkomponenten nicht frei verfügbar sind, und somit deren Nutzung für eine Umsetzung des Prototypen nicht brauchbar ist. 

\textit{Mumble} ist zwar als einziges dank seiner freien Lizenz modifizierbar, jedoch aufgrund der komplizierten Serverkonfiguration und einem komplexen Rechtesystem, das auf Gruppen und Regeln basiert, nicht einfach an die neuen Konzepte anzupassen. 
Zusätzlich zu den vorhandenen Problemen sind die drei Lösungen untereinander nicht kompatibel und bieten somit nur Insellösungen. 

\subsection{Dezentralisierte Sprachkommunikationslösungen}

Prinzipiell existiert eine Myriade an verschiedenen VoIP Programmen, die alle als dezentralisierte Lösungen eingesetzt werden können. Eine tatsächlich dezentrale Architektur kann jedoch bisher nur \textit{Skype} liefern. 

\subsubsection{\textit{Skype}}

Einen ganz anderen Ansatz verfolgt das Unternehmen Skype Technologies \footnote{Skype Technologies, Version 23.03.2008, http://www.skype.com}. Programm \textit{Skype} bietet innerhalb des eigenen Netzwerkes von registrierten Skype Benutzern die Möglichkeit des Instant Messaging, des Dateitransfers, der kostenlosen Telefonie über das Internet.
Von den Mitbegründern der Tauschbörse \textit{Kazaa} ins Leben gerufen, basiert Skype wie das Filesharingprogramm auf dem Peer-to-Peer Prinzip. Die Vermittlung, die Gespräche und auch Dienste wie das Teilnehmerverzeichnis werden nicht von einem zentralen Server angeboten, sondern werden auf alle gleichberechtigten Teilnehmer (den so genannten Peers) verteilt. Lediglich für die Authentifizierung und die Abrechnung bedient sich Skype eines zentralen Back-End-Servers. Das Skype Netzwerk unterscheidet zwischen einfachen Benutzern (Ordinary Hosts genannt) und den Super Nodes. 

Super Nodes sind Ordinary Hosts mit einer öffentlichen IP-Adresse und ausreichender Bandbreite, CPU-Leistung und Hauptspeicher und dienen als Endpunkte für die anderen
Hosts. Der Benutzer selber hat keinen Einfluss auf die Entscheidung, ob sein Rechner als Super Node fungiert oder nicht. In diesem Zusammenhang kann man bei Skype nicht von einer
reinen P2P Architektur sprechen, da nicht alle beteiligten Rechner gleiche Aufgaben übernehmen. 

Die \textit{Skype} Technologie ermöglicht als einziges ein völlig dezentrales VoIP. Der Einsatz des \textit{Skype} Dienstes und Clients ist kostenlos. Über das \textit{Skype-API }ist es auch für externe Programme möglich, auf die Funktionalitäten des \textit{Skype-Clients} und Teilen des Netzwerkes zuzugreifen.

Trotz der Vorteile bietet \textit{Skype} auch einige Nachteile: Über die Technik, die von der Skype Anwendung verwendet wird, ist nicht viel bekannt, da die gesamte Kommunikation per AES mit 256 Bit verschlüsselt wird, somit nicht zu analysieren ist und das Protokoll eine proprietäre Entwicklung von Skype Technologies ist. Somit kann das Protokoll nur mit der Originalsoftware genutzt werden. In der kostenlosen Version sind nur Konferenzen mit bis zu 5 gleichzeitigen Teilnehmern möglich. In einer kostenpflichtigen Version werden nur bis zu 10 gleichzeitige Konferenzteilnehmer unterstützt. 

Beide Versionen jedoch bieten auf Clientseite keine Kontrolle über die einzelnen Audioströme. So kann nur die Summe aller Audioströme empfangen werden. Die Clientanwendung ist nicht in der Lage einzelne Audioströme auszublenden oder die Lautstärke einzelner Teilnehmer zu ändern. Zudem bietet die \textit{Skype API} nur zwei spezielle Interfaces an um entweder Anrufe zu tätigen oder Nachrichten zu verschicken. Eine Architektur für weitere Dienste ist nicht vorgesehen \cite{schulzrinne05}.

Somit bietet \textit{Skype} als einziger tatsächlicher dezentralisierter Client nicht alle Eigenschaften um als mögliche Ausgangsgrundlage zu dienen. 

\subsection{Instant Messaging Anwendungen}
Andere Peer-to-Peer Programme wie \textit{Microsoft Netmeeting}\footnote{Microsoft, Version 20.03.2008, http://de.wikipedia.org/wiki/NetMeeting}, \textit{Microsoft Messenger}\footnote{Microsoft, Version 20.03.2008, http://messenger.live.com}, \textit{Google Talk}\footnote{Google, Version 20.03.2008, http://www.google.com/talk} sind nicht modifizierbar und nur sehr eingeschränkte Konferenzmöglichkeiten. 

\subsection{SIP Protokoll}
Das im darauf folgenden Kapitel vorgestellte SIP Protokoll und existierende Protokollstapel erfüllen die gestellten Anforderungen an den Prototypen. Da SIP ein generisches und offenes Protokoll ist, kann es kann benutzt werden, um beliebige Sitzungen mit einem oder mehreren Teilnehmern zu verwalten. Dabei ist es nicht auf Internet-Telefonie beschränkt sondern kann Sitzungen zwischen beliebigen Multimediaströmen, Konferenzen oder Computerspielen herstellen. Zahlreiche Standardisierungsorganisationen wie \textit{IETF \footnote{IETF, Version 22.03.2008, http://www.ietf.org/html.charters/sip-charter.html}, PINT, 3GPP\footnote{3GPP,Version 22.03.2008, http://www.3gpp.org/}, International Packet Communications Consortium \footnote{IPCC,Version 22.03.2008, http://www.imsforum.org/}, IMTC\footnote{ITMC, Version 22.03.2008, http://www.imtc.org/} und PacketCable \footnote{PacketCable, Version 22.03.2008, http://www.packetcable.com/}} unterstützen bereits den Einsatz von SIP.
%http://www.cs.columbia.edu/sip/

In der open-source Gemeinde wird das SIP Protokoll auch zunehmend unterstützt. So existieren bereits etliche Clientanwendungen und zentrale Komponenten wie \textit{Proxys} und \textit{Registrare}. Darüber hinaus finden sich zahlreiche gut dokumentierte SIP Protokollstapel und \textit{SDKs}. Es existieren auch Referenzimplementierungen, wie \textit{JAIN-SIP} \footnote{Sun Microsystems, Version 24.03.2008, http://jain-sip.dev.java.net} welches vom \textit{National Insitute of Standards and Technology \footnote{NIST, Version 24.03.2008, http://www.nist.gov}}entwickelt wurde, die sowohl in kommerziellen Projekten aber auch zu Forschungszwecken eingesetzt werden. Der wichtigste Grund für den Einsatz von SIP ist, dass es alle Anforderungen für die Umsetzung des Prototyps unterstützt:

\begin{itemize}
	\item Offener Standard
	\item Generisches Protokoll um Sitzungen zu verwalten
	\item Detaillierte Signalisierung von RTP Audioströmen
	\item Kontrolle über jeden einzelnen Audiostrom auf clientseite
	\item Serverbasierte Lösungen möglich
	\item Dezentralisierte Lösungen möglich
\end{itemize}

Um eine funktionierende Implementierung in kürzester Zeit umzusetzen, habe ich existierende offene SIP Protokollstapel in Betracht gezogen. Dabei wurde zwischen server- und clientbasierten Komponenten unterschieden. 

\subsubsection{SIP Server}
Für den Einsatz als Server bieten sich zwei große Pakete an die beide den SIP Standard nach RFC 3265 unterstützen. \textit{Asterisk}\footnote{Digium Inc, Programmversion 1.4.19, http://www.asterisk.org} unterstützt Voice-over-IP mit unterschiedlichen Protokollen  darunter sowohl SIP als auch das \textit{H323} Protokoll und bietet alle Möglichkeiten einer Anbindung an das Telefonnetz. 

Die Serveranwendung \textit{OpenSer}\footnote{AG Projects, Programmversion 1.3.1, http://www.openser.org} bietet ähnliche Funktionalität und kann als SIP-Proxy, Registrar, aber auch als Location- und Application-Server betrieben werden und bietet zusätzlich Unterstüztung für das SIP-SIMPLE Protokoll. \textit{OpenSer} ist sowohl von eingebetteten System wie DSL-Routern bis zu großen Installationen mit mehreren Millionen Benutzern bei Internet Service Providern flexibel einsetzbar. Diese Eigenschaften haben für mich den den Ausschlag gegeben Openser als SIP Server einzusetzen. 

Darüber hinaus existieren noch etliche open source als auch proprietäre SIP Server Lösungen, die hier nicht weiter erläutert werden. 

\subsubsection{SIP Clients}

Bei den SIP Clients existiert mittlerweile eine Vielzahl an speziellen ausgereiften kostenlosen \textit{Softphone} Lösungen Lösungen. Einige der bekanntesten open source Softphones für Linux und Windows sind \textit{Ekiga}\footnote{Damien Sandras, Version 24.03.2008, http://www.gnomemeeting.org/}, \textit{KPhone}\footnote{Jan Janak, Version 24.03.2008, http://sourceforge.net/projects/kphone} \textit{Linophone}\footnote{Antisip, Version 24.03.2008, http://www.linphone.org} oder \textit{Minisip}\footnote{
Telecommunications System Laboratory, Version 25.03.2008, http://www.minisip.org}. Bei diesen Softphones handelt es sich um kostenlose Projekte die frei eingesetzt und modifiziert werden können. 

Zusätzlich existieren zwar freie Softphones, die von Infrastruktur Betreibern kostenlos angeboten werden, um den eigenen Marktanteil am VoIP Markt zu erhöhen. Dazu gehören Programme wie \textit{X-Lite}\footnote{Counterpath, Version 21.03.2008, http://www.xten.com}, \textit{Gizmo5}\footnote{SIPphone Inc, Version 21.03.2008, http://gizmo5.com} oder \textit{OpenWengo}\footnote{OpenWengo Inc, Version 21.03.2008, http://www.openwengo.org}. Diese haben meist einen großen Funktionsumfang, lassen sich jedoch nicht modifizieren. Zudem sind sie an die Nutzung der Infrastruktur eines bestimmten Betreibers gebunden.

Eine ausführliche Übersicht über viele der auf dem Markt erhältlichen SIP Clients und Server Anwendungen findet sich unter \cite{sipsoftware08}.

\subusbsection{SIP Protokollstapel}
Neben kompletten Softphones existieren plattform-übergreifende SIP Protokollstapel, die die Funktionalität von SIP in größeren Anwendungen ermöglichen. Dazu zählen Protokollstapel wie \textit{OpenSipStack}\footnote{Joegen Baclor, Version 22.03.2008, http://www.opensipstack.org} \textit{sipXtackLib}\footnote{SIPfoundry, Version 22.03.2008, http://www.sipfoundry.org} \textit{reSIProcate}\footnote{B. Kampen, Version 22.03.2008, http://www.resiprocate.org} oder \textit{PJSIP}\footnote{B. Prijono, Version 22.03.2008, http://www.pjsip.org}

\subsubsection{Pjsip}
Meine persönliche Wahl fiel aus den folgenden Gründen auf den offenen SIP Protokollstapel \textit{PJSIP}:

\begin{itemize}
	\item Platformunabhängigkeit
	\item Mögliche Integration mit \textit{Irrlicht} dank C und C++ als Programmiersprache 
	\item Gute Dokumentation 
	\item Unterstützung des SIP Standards (PJSIP-CORE)
	\item Unterstützung des SIP-SIMPLE Standards (PJSIP-SIMPLE)
	\item Unterstützung für STUN, TURN und ICE (PJLIB-UTIL)
	\item Unterstützung moderner Audiocodecs wie z.B. \textit{Speex}(PJMEDIA-CODEC)
	\item Bereits existierender Mediastapel (PJMEDIA)
	\item Unterstützung von \textit{Asterisk} und \textit{Openser}
	\item Möglicher Einsatz auf mobilen Endgeräten
	\item Kontrolle jedes einzelnen Audiostroms (PJSUA-LIB)
\end{itemize}

\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.70\textwidth]{grafiken/pjsip.eps}
	\caption{Übersicht der Komponenten des PJSIP Protokollstacks}
	\label{fig:pjsip}
\end{figure}

Viele der existierenden SIP Clientanwendungen und Protokollstapel kamen für den Prototypen auch deshalb nicht in Frage, weil sie in einer anderen Programiersprache als C oder C++ geschrieben waren und so nicht in das 3D-Framework integriert werden konnten. 

\section{Entwicklungsumgebung}

\subsection[Programmiersprache}
Ich habe mich für den Einsatz von C und C++ aus mehreren Gründen entschieden. Die Darstellung der virtuellen 3D Welt und die die Etablierung, Verarbeitung und Wiedergabe der Audioströme bilden zusammen ein Echtzeitsystem. Da in so einem System der gleichzeitige Ablauf mehrerer Prozesse erforderlich ist, wird eine sehr performante Programmiersprache benötigt. Es sind vor allem kurze Reaktionszeiten erforderlich, um für den Spieler eine glaubwürdige Illusion zu erzeugen. Beim Audiosignal reichen bereits Verzögerungen von mehr als 300ms aus, um eine Verständigung unverständlich zu machen. 

Da C und C++ maschinennahe Sprachen sind, und keine Interpretation während der Laufzeit benötigen besitzen sie einen Effizienzvorteil gegenüber Sprachen wie JAVA. Gerade deswegen liegen fast alle bisher vorgestellten Protokollstapel und Bibliotheken für VoIP oder 3-D Grafik ausschließlich in C oder C++ vor. 

\subsection{Entwicklungsumgebung}
Die Entwicklung des Sourcecodes und der übrigen Teile dieser Arbeit wurden unter \textit{Windows XP} und \textit{Microsoft Visual Studio 8.0} durchgeführt. 

\subsection{Testumgebung}
Die immer wiederkehrenden Tests habe ich auf diversen mir zur Verfügung stehenden Systemen
durchgeführt.
Als MMPGP2P-Server kam mein Rechner anaconda zum Zuge, ein AMD Athlon(tm)
XP 2200+ mit DSL-Anbindung und fester IP-Adresse 213.146.116.174. Der Server läuft eben-
alls unter Debian GNU/Linux 3.1-Sarge mit Kernel 2.4.27. Ich habe den MMPGP2P-Server
tändig auf diesem System laufen lassen und nur während der Weiterentwicklung der Klassen
neu gestartet.
Für die Simulation von Clients habe ich zum einen meinen Rechner media einge-
setzt, eine Multimedia-Station mit Intel(R) Pentium(R) 4 CPU 2.40GHz und 100MBit-
Netzwerkanbindung an den Server. Auf diesem System lief Debian GNU/Linux 3.1-Sarge aller-
dings mit Kernel 2.6.11.6. Als weitere Clients kamen diverse Testumgebungen unter VMware
Workstation 3.2.0 build-2230 zum Einsatz, darunter Windows XP und Windows 98.
Weiteres ist im Kapitel 7 über Performanzmessungen beschrieben.

\section{Verbindungauf- und abbau}
\subsection{Verbindungsaufbau}
Befinden sich zwei Teilnehmer in einer entsprechenden Hörnähe, wir diese sie dazu veranlassen eine Verbindung untereinander aufzubauen. Dabei findet der Verbindungsaufbau entsprechend des SIP Protokolls statt, besitzt jedoch einen signifikanten Unterschied, der im folgenden erklärt werden soll:

Möchte Teilnehmer A möchte zu Teilnehmer B eine Verbindung herstellen sendet er eine SIP-Nachricht INVITE an Teilnehmer B. Die Nachricht enthält die Beschreibung der RTP-Session nach dem SDP Protokoll und alle notwendigen Angaben. 

Falls Teilnehmer B die Verbindung annehmen kann, prüft er, ob er gerade eine Verbindung zu A aufbaut, oder bereits eine Verbindung aufgebaut hat. Ist das der Fall so antwortet er auf den ankommenden Anruf mit der Response Nachricht 403 Forbidden. Diese Vorgehenswiese weicht vom SIP Standard ab und wird im anschließenden Abschnitt behandelt.

Baut Teilnehmer jedoch noch keine Verbindung zu Teilnehmer A auf und ist auch nicht mit ihm verbunden, so funktioniert der Rufaufbau wie gewohnt. Hat B den die Verbindung  akzeptiert, sendet er einen SIP-Response 200 OK der vom Teilnehmer A mit der Nachricht ACK bestätigt wird. Mit dem Empfang der ACK Nachricht von Teilnehmer B, ist die logische Verbindung abgeschlossen. Nun kann eine Verbindung nach dem Protokoll RTP verlaufen und es besteht eine Session zwischen den Teilnehmern. 

\subsubsection{Das Problem der doppelten Verbindung}
Da Teilnehmer zwar zentral Lokalisiert werden jedoch unabhängig von einer zentralen Instanz Verbindungen aufbauen können, kann der Fall auftreten, dass beide Teilnehmer zeitgleich eine Verbindung miteinander aufbauen wollen. Dieser Fall tritt immer dann auf, wenn beide Spieler im Spiel die erforderliche Nähe zueinander erreicht haben. Dann versucht sowohl Teilnehmer A eine Verbindung zu Teilnehmer B aufzubauen, als auch Teilnehmer B eine Verbindung zu Teilnehmer A aufzubauen. Dies entspricht dem Problem im Alltag, wenn zwei Personen sich versuchen zur exakt gleichen Zeit anzurufen und jeder nur ein Besetztzeichen hört. 

Bei diesem Szenario können zwei verschiedene Fälle auftreten. Der einfache Fall liegt vor, wenn eine INVITE Nachricht von A eintritt und B bereits mit A verbunden ist. Dann kann er den zweiten Dialog einfach verwerfen, da ja bereits eine bestehende Verbindung existiert.

Der kompliziertere Fall ist der symmetrische Fall: Dieser tritt dann ein wenn B, während er selbst eine Verbindung mit A aufbaut, die INVITE Nachricht erhält. Hier hat B hat ebenfalls eine INVITE Nachricht an A geschickt, während A zur gleichen Zeit auch eine INVITE Nachricht an B geschickt hat. Lehnen nun beide Teilnehmer die Verbindung ab, so führt es dazu dass in diesem Fall überhaupt keine Verbindung zwischen den Teilnehmern zustande kommt. 

Hierbei ist es wichtig, dass eine gemeinsame Regel für alle Teilnehmer existiert nach der beim Dialog Aufbau vorgehen. Ich habe mich dafür entschieden, dass in diesem Fall beide Teilnehmer die Verbindung ablehnen, und solange versuchen ein eine neue Verbindung zu etablieren bis der unsymmetrische Fall auftritt. Diese Vorgehensweise hat sich in der Praxis bewährt, da meist ein Teilnehmer schneller akzeptiert als der andere. Zudem braucht man keine lexikalische Sortierung der Teilnehmer vorzunehmen um einen dominierenden Peer zu ermitteln. 

\subsection{Verbindungsabbau}
Der Verbindungsabbau findet wie gewohnt statt: Befindet sich Teilnehmer B nicht mehr in Verbindungsreichweite zu Teilnehmer A so beenden beide die Verbindung zueinander. Dazu senden sie eine BYE Nachricht an den anderen Teilnehmer, die mit einer ACK Nachricht bestätigt wird. 

\section{Zonen}
Die Umgebung des Spielers wurde wie gefordert in drei Zonen unterteilt. 

\subsection{Öffentliche Zone}
Die Öffentliche Zone dient zum initiieren von SIP Verbindungen des Spielers mit anderen Teilnehmern, die sich in seiner Öffentlichen Zone befinden. Da der Verbindungsaufbau mitunter bis zu 1 oder 2 Sekunden betragen kann, wird diese Zone dazu genutzt bereits vorab Verbindungen zu etablieren, bevor die Teilnehmer tatsächlich in der Lage sind miteinander zu sprechen. So soll die entstehende Latenz beim Verbindungsaufbau für den Spieler nicht erkennbar sein. 

Durch die Existenz der öffentlichen Zone herrscht ein gradueller Übergang von nicht Verbundenen Teilnehmern, über Teilnehmer die bereits auf logischer Ebene Verbunden sind aber noch keine Audiodaten austauschen. In dieser Übergangphase werden logische SIP Verbindungen aus dem Grund aufrechterhalten, weil es sehr wahrscheinlich ist, dass die Teilnehmer die bereits diese Entfernung eingenommen haben die soziale Zone betreten werden, in der tatsächlich eine Audioverbindung stattfindet. Da Spielergruppen in virtuellen Welten der Erfahrung nach meist in größeren Anzahlen miteinander in die gleiche Richtung wandern, soll durch eien Öffentliche Zone sichergestellt werden, dass bereits eine Konnektivität zwischen allen Teilnehmern herrrscht, damit ohne Verzögerungen eine Sprachkommunikation etabliert werden kann. Diese Konnektivität soll eine minimale Bandbreite beanspruchen, trotzdem aber einen schnellen Verbindungsaufbau ermöglichen. 

\subsubsection{Eingang und Verlassen der Öffentlichen Zone}
Die öffentliche Zone kann aus zwei Richtungen betreten werden. Wird sie von außen betreten, wird eine SIP Verbindung zwischen den Teilnehmern aufgebaut. Der Verbindungsaufbau und die damit eingehenden Probleme wurden oben bereits beschrieben. Wird die Zone von innen betreten. dh. findet ein Übergang von der sozialen Zone zur öffentlichen Zone statt, so findet auf Protokollebene folgender Ablauf statt:

\subsubsection{RTP - Silence Supression}
Der logische SIP Anruf bleibt weiterhin erhalten, während auf auf RTP Ebene kein weiteres Audiosignal mehr übertragen wird. Dies geschieht indem der Teilnehmer aus der internen Conference Bridge genommen wird. Das bedeutet dass beide Spieler das gegenseitige Audiosignal nicht mehr empfangen da beide Teilnehmer eine Silence Suppression vornehmen. Dies entspricht der im Kapitel 3 geschilderten Eigenschaften von Silence Supression von RTP und RTCP, nur dass sie hier nicht in Abhängigkeit der tatsächlichen Stille im Mikrofon, sondern der Enfernung der Teilnehmer zueinander stattfindet. Durch diese Methode bietet die Möglichkeit, einerseits den Bandbreitenverbrauch in dieser Zone minimal zu halten, aber gleichzeitig in den Teilnehmern einen verzögerungsfreien Wechsel zurück in die soziale Zone zu ermöglichen, da der Wechsel von Silence Supression zurück zu normaler übertragung kein neues aushandeln der Parameter benötigt. 

\subsubsection{SIP - HOLD}
Das gleiche Prinzip wurde ebenfalls mit der SIP HOLD Funktionalität ausprobiert, was wie in den Messergebnissen zu sehen ist, zwar zu einer noch größeren Einsparung der Bandbreite geführt hat, aber als Nachteil eine Verzögerung beim wiederaufnehmen des Calls bewirkte, da die Verbindungsparameter beim Wiederaufnehmen des Gesprächs wieder neu verhandelt wurden.
%TODO Ablaufdiagrapp SIP HOLD

\subsection{Soziale Zone}
In der Sozialen Zone werden die Teilnehmer, der bereits aufgebauten Verbindungen unserer eigenen lokalen Konferenz hinzugefügt. Innerhalb der Konferenz wird die Lautstärke der Teilnehmer gemäß ihrer Entfernung angepasst. Audiosignale von Teilnehmern, die sich am inneren Rand der Sozialen Zone des Spielers befinden werden ungedämpft mit einer Lautstärke von 100\% abgemischt. Die Lautstärke der Spieler nimmt linear in Abhängigkeit der Entfernung ab, bis sie am äußersten Rand der Zone 0\% beträgt. 

\subsubsection{Lautstärkenanpassung}
Da die Lautstärke der Übertragenen Stimme bei einer Übertragung durch Luft mit zunehmender Entfernung abnimmt haben wir ein einfaches physikalisches Modell benutzt: Generell gilt, dass Schalldruck bei zunehmender Entfernung r  mit 1/r abnimmt. Da sich die Schallintensität auf eine immer größer werdende gedachte Kugeloberfläche (proportional zur Entfernung r) verteilt, nimmt sie mit der Entfernung quadratisch ab. 

Wir haben zu Testzwecken sowohl die lineare Abnahme der Schallintensität als auch die quadratische Abnahme der Schallintensität modelliert, um festzustellen welche Veränderung in einer Konferenz natürlicher erscheint. Ein Problem bei der Implementierung bleibt, dass Mikrofone eine unterschiedliche Aufnahmelautstärke haben, so dass manche Spieler ein lauteres Signal besitzen als andere. In einem fertigen Produkt, sollte auf das Mikrofon dynamisch auf einen bestimmten Pegel normiert werden, bevor das Spiel beginnt. Solche Verfahren sind Standard bei VoIP Telefonen und könnten später leicht nachgerüstet werden. %http://www.sengpielaudio.com/Rechner-entfernung.htm

\subsubsection{Audiocodec}
In der sozialen Zone wird ein Audiocodec mit einer niedrigen Bitrate eingesetzt, um eine größere Anzahl an möglichen Mitspielern zu ermöglichen. Ich habe mich für den Speex Codec mit einer Abtastrate von 16kHz und einer Bitrate von 11 Kbps entschieden, der einen MOS Wert von über 4 liefert. Es ist natürlich vorstellbar auch qualitativ schlechtere Codecs mit einer noch geringeren Bitrate einzusetzen, um dem Spieler noch mehr Verbindungen zu ermöglichen. Diese Entscheidung kann in einem fertigen Produkt entweder dem Spieler überlassen bei einer manuellen Konfiguration überlassen werden oder automatisch anhand der verfügbaren Bandbreite bestimmt werden. So könnten Spieler mit einer höheren Bandbreite auch ein besseres Audiosignal verbreiten, während Spieler mit einer schwachen Anbindung nur Codecs mit einer niedrigen Bitrate einsetzen könnten.

\subsection{Private Zone}

\subsubsection{Lautstärke}
In der privaten Zone A variiert die Laut\-stärke der Teilnehmer nicht in Ab\-hän\-gig\-keit von ihrer Distanz. Hier wird die sie konstant auf 100\% gehalten, um den Teilnehmern zu ermöglichen sich in einem kleinen Radius untereinander zubewegen, aber immer noch mit einer optimalen Lautstärke zu kommunizieren. 

\subsubsection{Audiocodec}
In der Audiocodec Variante wird für die Private Zone ein höherwertigerer Codec mit einem größeren MOS Wert gewählt. Diese Vorgehensweise soll dafür sorgen, das Mitspieler in unmittelbarer Nähe besonders gut verständlich sind. Im Gegensatz zur Sozialen Zone werden nur wenige Spieler erwartet die sich in dieser Zone befinden, da man speziell auf den Spieler zulaufen muss um sich in diese Zone zu begeben und dann meist der Wunsch besteht mit diesem Spieler zu kommunizieren. In der Implementierung wurde für die Private Zone der Speex Codec mit einer Abtastrate von 32 kHz verwendet, während in der Sozialen Zone der Speex Codec mit einer geringen Abtastrate von 8kHz eingesetzt wurde. 

\subsection{Radar}

In einem Radar werden für den Spieler alle Teilnehmer des Spiels angezeigt. Der Radar besitzt ebenfalls drei Zonen, die die Verbindungsstufen anzeigen. Spieler werden einem Icon und ihrem zugehörigen Namen angezeigt. In der öffentlichen Zone wird der Icon gräulich angezeigt, betreten sie die soziale Zone werden dieser grün gefärbt und in der privaten Zone ist ihr Icon gelb. So ist der Spieler jederzeit in der Lage zu wissen welche Spieler er gerade adressiert und welche Spieler er auch hören kann.

Die Metapher der Luftübertragung mit dem Radar als Orientierungshilfe hilft das Problem der Addressierung in den Griff zu bekommen. Spieler sind in der Lage zu sehen an wen ihre Sprachnachrichten gehen und wen sie gerade hören. 

\subsection{PTSN Netzwerke}
Durch die Möglichkeit SIP Server mit externen Gateways zu verbinden, wurde auch die Metapher des Festnetz-Telephons umgesetzt, dass dem Spieler tatsächlich erlaubt aus der virtuellen Welt in die reale Welt zu telefonieren. Hier wurde eine Telefonzelle auf dem Spielfeld platziert. Befindet sich der Spieler in unmittelbarer Nähe zu dieser Zelle, findet ein Anruf an eine beliebige Telefonnumer statt. Dieser Proof of Concept zeigt, dass mit Hilfe eines standartisierten Protokolls auch solche Möglichkeiten offen stehen. 

\section{Spielewelt in Irrlicht und Irrklang}

\subsection{Irrlicht}
%Todo bild vom Level
\subsubsection{Level}
Für eine möglichst realistische Umsetzung haben wir ein Level benutzt, das einen Park zeigt, und dem Spieler die Möglichkeit bietet sich in diesem Park frei zu bewegen. Die Metapher des Parks und Menschen die sich im Park bewegen erlaubt die spontane Kommunikation untereinander. Ebenso erscheint in diesem Szenario die Übertragung der Sprache per Luft sehr natürlich. 

\subsubsection{Collision Detection}
Unter Collision Detection versteht man eine Berechnung der Kollisionen des Spielers mit seiner Umgebung. Der Spieler kann in der Implementierung mit andern Spielern des Levels und dem Level selbst interagieren. Ohne Collision Detection, könnte der Spieler alle Gegenstände durchdringen. Diese Aufgabe wurde mit der Hilfe der Irrlicht Engine umgesetzt. 

\subsubsection{Steuerung}
Der Spieler ist in der Lage sich in alle Richtungen zu Bewegen und zu springen.

\subsection{Irrklang}

\subsubsection{Lokale Audiszene}
%TODO Bild von Springbrunnen
Das Level wurde zusätzlich mit mehreren lokalen Audioquellen ausgestattet, die eine realistische Audioumgebung simulieren. So sind Wind, Springbrunnen und die Fahrzeuge des Levels mit Audiodateien unterlegt, die durch die Irrklangengine  gerendert werden. Diese Audioszene wird lokal erzeugt und muss nicht im Gegensatz zur Sprachkommunikation über das Netzwerk übertragen werden. Die Sprachkommunikation und die lokale Audioszene existieren gleichzeitig und erzeugen so für den Spieler ein eine realistische Audioszene. 

\section{Zusammenarbeit von Irrlicht und VoIP}

\subsection{Aktualisierung der VoIP Instanz}

Im Spiel selbst ist der Irrlicht Scene Manager verantwortlich alle Objekte der Szene zu verwalten. Er verfügt auch über die die (X,Y,Z) Koordinaten aller Spieler im Spiel. Die im Scene Manager enthaltenen Objekte durch die Spielelogik verwaltet. 

Der Scene Manager enthält dabei nicht nur Objekte des Levels sondern auch die Spielfiguren aller Spieler. Erhält der Spieler neue Positionsinformationen so werden die entsprechenden Spieler im SceneManager aktualisiert. 

Die VoIP Instanz fragt periodisch beim SceneManager die Koordinaten der aktiven Spieler ab um die Distanzvektoren neu zu berechnen. Anhand dieser nimmt sie das Mischen der Audioströme der Spieler vor. 

\subsection{Buddy Concept}

Die Spieler im Spiel werden durch Avatare repräsentiert. Jedem Avatar im Spiel ist ein entsprechender Buddy in der VoIP Instanz gegenübergestellt.
Die VoIP Instanz hält eine lokale Liste von Buddies vor. Sämtliche Sprachkommunikation findet durch einen Anruf zum entsprechendem Buddy statt. Es sind auch mehrere Anrufe möglich wenn sich mehrere Personen in der Hörnähe befinden. Dadurch dass für jeden Spieler ein eigener Anruf verwaltet wird, sind wir in der Lage die Parameter, wie Lautstärke oder auch Bitrate und Codec jedes einzelnen Anrufs zu verwalten und auszuhandeln.

\section{Spielablauf - Use Cases}

\subsection{Registrierung}
Bevor das eigentliche Spiel stattfindet registriert sich der Spieler bei einem voreingestellten Registrar. Dazu sendet er seine Anmeldung gemäß im Kapitel 3 vorgestellten Registrierungsprozess. Ist die Registrierung abgeschlossen ist der Registrar in der Lage diesen Spieler erfolgreich zu lokalisieren.

\subsection{NAT Traversal}
Peer-to-Peer Anwendungen haben oft mit dem Problem zu kämpfen, dass sie hinter Routern und NATs nicht funkionieren, da die einzelnen Clients nicht erreichbar sind. Das gleiche Problem besitzen VoIP Anwendungen. Bei Spielen wird das Problem oft manuell gelöst, indem jeder einzelne Änderungen an Router, Firewall und NAT vornimmt um entsprechende Ports freizugeben. Dadurch, dass SIP mit dem STUN Protokoll arbeitet sind wir in der Lage im Spiel ohne die Rekonfiguration von Endgeräten auch hinter Routern, Firewalls und NATs zu operieren. Die Funktionsweise von STUN wurde Detailiert im Kapitel 3 beschrieben und wird auch entsprechend hier im Spiel angewandt. Dazu wird bei der Registrierungsphase ein öffentlicher STUN Server angegeben, der dann kontaktiert wird und dem Spieler erlaubt seine öffentliche IP Adresse und den Typ des eingesetzten Routers herauszufinden. 

\subsection{Spieler startet das Spiel}
Auf dem Startbildschirm sieht der Spieler alle seine bisherigen Freunde und kann sofort ihren Status sehen: Freunde können entweder offline sein, online sein oder im Spiel. Will der Spieler das Spiel betreten, kann er einen aktiven Spieler anwählen und Join drücken. Möchte er ein neues Spiel starten kann er mittels Create ein neues Spiel anlegen. 

\subsection{Neuer Spieler betritt das Spiel}
Betritt ein neuer Spieler das Spiel, so wird er zunächst von der Irrlicht Engine im Spiel dargestellt. Für jeden neuen Spieler wird an einer Einstiegskoordinate ein Avatar erzeugt. Zusätzlich dazu wird die SIP Adresse neuen Teilnehmers in die lokale Buddyliste des Spielers aufgenommen. Da alle Spieler der Buddyliste potenzielle Kandidaten für eine Sprachkommunikation muss jeder Spieler des Spiels auch in der Buddyliste geführt werden. Befindet sich der entsprechende Spieler in Hörnähe wird ein Anruf zu diesem Teilnehmer in der VoIP Instanz ausgeführt.

\subsection{Spieler bewegt sich im Spiel}
Jeder Spieler ist in der Lage sich frei im Level zu bewegen. Jede der Bewegungen wird den anderen Teilnehmern mitgeteilt, damit sie in der Lage sind die Spielwelt abzugleichen. Der Spieler selbst abonniert ebenfalls alle Spielerinformationen aller Spieler eines aktiven Spiels. Anhand der Positionsinformationen der Spieler wird die Sprachkommunikation entsprechend des Zonenkonzepts eingeleitet.

\subsection{Spieler beendet sein Spiel}
Beendet ein Spieler sein Spiel, so bedeutet es für die übrigen Spieler nicht, dass das komplette Spiel auch beendet ist. Das Verlassen eines Spielers hat die einzige Auswirkung, dass dieser Spieler keine Positionsinformationen mehr versendet und empfängt. Alle aktiven Gespräche mit diesem Spieler werden ebenfalls beendet. Die übrigen Spieler im Spiel können das Spiel jedoch ohne Unterbrechung weiterführen. 
//TODO