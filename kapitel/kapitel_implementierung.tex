\chapter{Implementierung}


\section{Entwicklungsumgebung}
\subsection{Programmiersprache}
\subsection{Build und Testumgeung}

\cite{schulzrinne05} -- Peer-to-Peer SIP Assumptions

Um eine funktionierende Implementierung in kürzester Zeit umzusetzen, habe ich einige existierende offene SIP Stacks in Betracht gezogen.

\subsection{SIP Server}
Für den Einsatz als Server bieten sich zwei große Pakete an die beide den SIP Standard nach RFC 3261 unterstützen. 
Asterisk (Version 1.4.19) unterstützt Voice-over-IP (VoIP) mit unterschiedlichen Protokollen  darunter sowohl SIP als auch das H323 Protokoll und bietet alle Möglichkeiten einer Anbindung an das Telefonnetz. 
Die Serveranwendung OpenSer (Version 1.3.1) bietet ähnliche Funktionalität kann als SIP-Proxy, Registrar, aber auch als Location- und Application-Server betrieben werden und bietet zusätzlich das Unterstüztung für das SIP-SIMPLE Protokoll, was den Ausschlag gegeben hat diesen SIP Server zu benutzen. OpenSER ist flexibel einsetzbar, von eingebetteten System wie DSL-Routern bis zu großen Installationen mit mehreren Millionen Benutzern bei Internet Service Providern.
Darüber hinaus existieren noch etliche andere sowohl open source als auch propriätere SIP Server Lösungen, die hier nicht weiter erläutert werden. 

\subsection{Existierende SIP Clients}
%Linux
%http://sourceforge.net/projects/kphone
%www.linphone.org
%Windows
%www.xten.com 
%http://www.minisip.org
%http://gizmo5.com/

Bei den SIP Clients existiert mittlerweile eine Vielzahl an speziellen ausgereiften kostenlosen Softphone Lösungen Lösungen. Einige der bekanntesten open source Softphones für Linux und Windows sind das Ekiga, KPhone oder Linophone, Minisip. Bei diesen Softphones handelt es sich um kostenlose Projekte die frei eingesetzt und modifiziert werden können. Zusätzlich existieren zwar freie Softphones, die von Infrastruktur Betreibern kostenlos werden um den eigenen Marktanteil am VoIP Markt zu erhöhen. Dazu gehören Programme wie X-Lite, Gizmo5 oder OpenWengo, deren Einsatz meist mit der Nutzung der Infrastruktur eines bestimmten Betreibers empfohlen oder vorgesehen wird. 
Zusätzlich zu kompletten Softphones existieren plattformübergriefende SIP Stacks die die Funktionalität von SIP in größeren Anwendungen ermöglichen sollen. Dazu zählen Stacks wie OpenSipStack, sipXtackLib, reSIProcate oder PJSIP.
Eine ausführliche Übersicht über viele der auf dem Markt erhältlichen SIP Clients und Server Anwendungen findet sich unter \cite{sipsoftware08}.

\subsubsection{Pjsip}
Meine persönliche Wahl fiel aus den folgenden Gründen auf PJSIP:
\begin{itemize}
	\item Platformunabhängigkeit
	\item Mögliche Integration mit Irrlicht wegen C und C++ als Programiersprache
	\item Gute Dokumentation 
	\item Unterstützung des SIP und SIP-SIMPLE Standards 
	\item Unterstützung für STUN, TURN und ICE
	\item Unterstützung von Asterisk und Openser
	\item Möglicher Einsatz auf Mobilen Endgeräten
	\item Unterstützung für moderne Audiocodecs wie z.B. Speex oder G.711
	\item Bereits existierender Mediastack mit einer logischen Conference Bridge
	\item Möglichkeit der Anpassung der Lautstärke der einzelnen Audiostreams
\end{itemize}

%Bild PJSIP

Viele der existierenden SIP Stacks kamen für den Prototypen auch deshalb nicht in Frage, weil sie in einer anderen Programiersprache als C oder C++ geschrieben waren und so mit der 3D-Engine nicht integriert werden konnten. 

\section{Protocoll Messages}
\subsection{Herstellen einer Verbindung}

\subsubsection{Das Problem der doppelten Verbindung}
Da Teilnehmer unabhängig von einer zentralen Instanz verbindungen Aufbauen, tritt der Fall, dass beide Teilnehmer zeitgleich eine Verbindung miteinander aufbauen immer dann auf, wenn sie die erforderliche Nähe zueinander erreicht haben. Dann Versucht sowohl Teilnehmer A eine Verbindung zu Teilnehmer aufzubauen, als auch Teilnehmer B eine Verbindung zu Teilnehmer A aufzubauen. Dies entspricht dem problem im alltag, wenn zwei Personen sich versuchen zur exakt gleichen Zeit anzurufen. 

Dabei existieren zwei verschiedene Szenarios für diesen Fall. Der einfache Fall ist wenn eine INVITE Nachricht von A eintritt und B bereits mit A verbunden ist. Dann kann er einfach den Dialog verwerfen. Der kompliziertere Fall ist, wenn B gerade eine Verbindung mit A aufbaut und die INVITE Nachricht erhält, das bedeutet das B ebenfalls gerade eine Verbindung mit A aufbaut und die Situation symetrisch ist. Hierbei ist es wichtig, dass eine gemeinsame Regel existiert nach der die Teilnehmer den Dialog aufbauen. Ich habe mich dafür entschieden, dass in diesem Fall beide Teilnehmer die Verbindung ablehnen, und eine neue Verbindung zu etablieren bis der unsymmetrische Fall auftritt. Diese Vorgehensweise hat sich in der Praxis bestätigt, da ein Teilnehmer meistens schneller akzeptiert als der andere Teilnehmer. 

\subsubsection{Verbindungsaufbau}

Teilnehmer A möchte zu Teilnehmer B eine Verbindung herstellen. Dazu sendet er eine SIP-Nachricht INVITE an Teilnehmer B. Die Nachricht enthält die Beschreibung der RTP-Session nach dem SDP Protokoll und alle notwendigen Angaben, wie z.B. die Sprachkodierung, damit Teilnehmer B Prüfen kann ob eine Session hergestellt werden kann. 
Falls Teilnehmer B die Verbindung annehmen kann, klingelt das angerufene IP-Telefon von Teilnehmer B, dies wird mit der SIP-Response 180 Ringing signalisiert. 

Hier prüft nun Teilnehmer B, ob er bereits eine Verbindung zu A aufbaut. Ist das der Fall so antwortet er auf den ankommenden Anruf mit der Response Nachricht 403 Forbidden. Da wir nur eine Verbindung zwischen den Teilnehmern benötigen, brechen wir den zweiten Verbindungsaufbau ab.

Baut Teilnehmer jedoch noch keine Verbindung zu Teilnehmer A auf und ist auch nicht mit ihm verbunden, so funktioniert der Rufaufbau wie gewohnt. Hat B den die Verbindung  akzeptiert, sendet er einen SIP-Response 200 OK der vom Teilnehmer A mit der Nachricht ACK bestätigt wird. Mit dem Empfang der ACK Nachricht von Teilnehmer B, ist die logische Verbindung abgeschlossen. Nun kann eine Verbindung nach dem Prtokoll RTP verlaufen und es besteht eine Session zwischen den Teilnehmern. 
Die bestehende RTP-Session kann von beiden Seiten beendet werden. Beendet Teilnehmer B durch das Absenden der SIP Nachricht BYE die Session, bestätigt Teilnehmer A den Empfang der Nachricht mit der SIP-Response 200OK. Mit dem Empfang von 200 OK beim beim Teilnehmer B wird die Session beendet. 

\subsection{Verbindungsabbau}
Befindet sich Teilnehmer B nicht mehr in Verbindungsreichweite zu Teilnehmer A so veranlassen beide die Verbindung zu beeden. Dazu sendet ein Teilnehmer eine BYE Nachricht an den anderen Teilnehmer, die mit einer ACK Nachricht bestätigt wird. 

\section {Erweitertes Audio Mixing}
Wie wir festgestellt haben ist die Teilnahme an einer Konferenz binär gelöst worden. Soieler sind entweder Teil einer Konferenz oder nicht. So ist in einer Konferenz mit \textit{n} Teilnehmern ${p_{1},p_{2},...,p_{n}}$, mit Audioströmen ${V_{1},V_{2},...,V_{n}}$, das von einem Teilnehmer $p_{i}$ zu einer Zeit \textit{t} empfangene Signal definiert durch:
	\[
\begin{align}
	R_{i}(t) = \sum{V_{j}(t)} \mbox{,wobei 1 \geq j \geq n} \mbox{und j $\neq$ i}
\end{align}
\]
Das Szenario das wir aber vorstellen soll über den binären Status einer Konferenz hinausgehen und die Teilnahme an einer Konferenz von der Distanz $d_{j}$ zum anderen Teilnehmer abhängig machen. Das empfangene Signal würde damit definiert durch:

	\[
	\begin{align}
	R_{i}(t) = \sum{d_{j} \cdot V_{j}(t)} \mbox{ wobei 1 \geq j \geq n} \mbox{ und j \neq i}
	\end{align}
\]

Der Distanzvektor wird dabei immer vom Spieler anhand der Spielerinformationen berechnet und die Lautstärke des enstprechenden Audiostroms  mit diesem Vektor reguliert.

\section{Zonen}
Die Umgebung des Spielers wurde wie gefordert in drei Zonen unterteilt. 

\subsection{Öffentliche Zone C}
Der Teilnehmer stellt in der Zone C Verbindungen zu Teilnehmern dieser Zone statt. Da der Verbindungsaufbau mitunter bis zu 1 oder 2 Sekunden betragen kann wird diese Zone dazu genutzt bereits vorab Verbindungen zu etablieren, bevor die Teilnehmer tatsächlich in der Lage sind miteinander zu sprechen. So soll die entstehende Latenz vom Verbindungsaufbau für den Spieler nicht sichtbar sein. Diese Zone soll auch dafür sorgen dass eine gewisse Unschärfe existiert, was die Verbindungen zwischen den Teilnehmern angeht. In dieser Übergangphase werden logische Verbindungen aus dem Grund aufrechterhalten, weil es sehr wahrscheinlich ist dass die Teilnehmer wieder die soziale Zone betreten.

\subsubsection{Eingang und Verlassen der Öffentlichen Zone}
Die öffentliche Zone kann aus zwei richtungen betreten werden. Wird sie von außen betreten wird eine Verbindung zwischen den Teilnehmern aufgebaut. Der Verbindungsaufbau und die damit eingehenden Probleme wurden oben bereits beschrieben. Wird die Zone von innen betreten. dh. findet ein Übergang von der Sozialen Zone zur öffentlichen Zone statt, so findet auf Protokollebene folgendes statt.

\subsubsection{RTP - Silence Supression}
Der logische SIP Anruf bleibt weiterhin erhalten, während auf auf RTP Ebene kein weiteres Audiosignal mehr übertragen wird. Dies geschieht indem der Teilnehmer aus der internen Conference Bridge genommen wird. Das bedeutet dass der Spieler das Audiosignal des Teilnehmers nicht mehr empfängt da beide Teilnehmern eine Silence Suppression vornehmen. Dies entspricht der im Kapitel 3 geschilderten Eigenschaften von Silence Supression von RTP und RTCP, nur dass sie hier nicht in Abhängigkeit der tatsächlichen Stille, sondern der Enfernung der Teilnehmer zueinander stattfindet. Durch diese Methode sind wir in der Lage einerseits den Bandbreitenverbrauch in dieser Zone minimal zu halten, aber gleichzeitig in der Lage Teilnehmern einen verzögerungsfreien Wechsel zurück in die soziale Zone zu ermöglichen. 

\subsection{Soziale Zone B}
In der Zone B werden nun die Teilnehmer der bereits existierenden Verbindungen unserer eigenen lokalen Konferenz hinzugefügt. Innerhalb der Konferenz wird die Lautstärke der Teilnehmer gemäß ihrer Entfernung angepasst. Teilnehmer die sich unmittelbar in der nähe des Spielers befinden haben die Lautstärke von 100\% während Teilnehmer die sich am äußersten Rand der Zone befinden eine Lautstärke von 0\% besitzen.

\subsubsection{Lautstärkenanpassung}

Da die Lautstärke der Übertragenen Stimme bei einer Übertragung durch Luft mit zunehmender Entfernung abnimmt haben wir ein einfaches physikalisches Modell benutzt: Generell gilt, dass Schalldruck bei zunehmender Entfernung r  mit 1/r abnimmt.  Da sich die Schallintensität auf eine immer größer werdende gedachte Kugeloberfläche (proportional zur Entfernung r) verteilt, nimmt sie mit der Entfernung quadratisch ab. 

Wir haben zu Testzwecken sowohl die lineare Abnahme der Schallintensität als auch die quadratische Abnahme der Schallintensität modelliert, um festzustellen welche Veränderung in einer Konferenz natürlicher erscheint. 
%http://www.sengpielaudio.com/Rechner-entfernung.htm

\subsection{Private Zone A}
In der privaten Zone A variiert die Lautstärke der Teilnehmer nicht in Abhängigkeit von ihrer Distanz. Hier wird die sie konstant auf 100\% gehalten, um den Teilnehmern zu ermöglichen sich in einem kleinen Radius untereinander zubewegen, aber immer noch mit einer optimalen Lautstärke zu kommunizieren. 

\subsection{Radar}

In einem Radar werden für den Spieler alle Teilnehmer des Spiels angezeigt. Der Radar besitzt ebenfalls drei Zonen, die die Verbindungsstufen anzeigen. Spieler werden einem  Icons und ihrem zögehörigen Namen angezeigt. In der Öffentlichen Zone werden wird der Icon gräulich angezeigt, betreten sie die soziale Zone werden dieser grün gefärbt und in der privaten Zone ist ihr Icon gelb. So ist der Spieler jederzeit in der Lage zu wissen welche Spieler er gerade adressiert und welche Spieler er auch hören kann.

Die Metapher der Luftübertragung mit der orientierungshilfe des Radars Hilft uns die das Problem der Addressierung in den Griff zu bekommen. Wir sind so in der Lage zu sehen an wen unsere Sprachnachrichten gehen und wen wir gerade hören. Möchten wir eine Person besser hören so müssen wir nur dafür sorgen, dass wir uns dieser Person auf dem Spielfeld nähren.  

\section{Spielewelt in Irrlicht und Irrklang}

\subsection{Irrlicht}
%Todo bild vom Level
\subsubsection{Level}
Für eine möglichst realistische Umsetzung haben wir in der 3D-Engine ein Level benutzt, das einen Park zeigt, und dem Spieler die Möglichkeit bietet sich in diesem Park frei zu bewegen. 

\subsubsection{Collision Detection}
Unter Collision Detection versteht man eine Berechnung der Kollisionen des Spielers mit seiner Umgebung. So kann der Spieler mit Gegenständen des Levels und dem Level selbst interagieren. Würde keine Collision Detection exisiteren, könnte der Spieler durch die Gegenstände laufen. Diese Aufgabe wird mit der Hilfe der Irrlicht Engine erledigt. 

\subsubsection{Steuerung}
Der Spieler ist in der Lage sich in alle Richtungen zu Bewegen und zu springen.

\subsection{Irrklang}

\subsubsection{Lokale Audiszene}
%TODO Bild von Springbrunnen
Das Level wurde zusätzlich mit mehreren lokalen Audioquellen ausgestattet, die eine realistische Audioumgebung simulieren. So sind Wind, Springbrunnen und die Fahrzeuge des Levels mit Audiodateien unterlegt, die durch die Irrklangengine  gerendert werden. Diese Audioszene wird lokal erzeugt und muss nicht im Gegensatz zur Sprachkommunikation über das Netzwerk übertragen werden. Die Sprachkommunikation und die lokale Audioszene existieren gleichzeitig und erzeugen so für den Spieler ein eine realistische Audioszene. 

\section{Zusammenarbeit von Irrlicht und VoiP}

\subsection{Aktualisierung der VoIP Instanz}

Im Spiel selbst ist der Irrlicht Scene Manager verantwortlich alle Objekte der Szene zu verwalten. Er verfügt auch über die die X,y,Z Koordinaten aller Spieler im Spiel. Die im Scene Manager enthaltenen Objekte werden von der Spielelogik verwaltet. Erhält der Spieler neue Positionsinformationen so werden die entsprechenden Spieler im SceneManager aktualisiert. 

Die VoIP Instanz fragt periodisch beim SceneManager die Koordinaten der aktiven Spieler ab um die Distanzvektoren neu zu berechnen und so das Mischen der Audioströme entsprechend der Positionen der Spieler anzupassen.

\subsection{Buddy Concept}

Die Spieler im Spiel werden durch Avatare repräsentiert, jedem Avatar im Spiel ist ein entsprechender Buddy in der VoIP Instanz gegenübergestellt.
Die VoIP Instanz hält eine lokale Liste von Buddies vor, über deren Status sie Anhand der Präsenzinformation informiert ist. 

\section{Spielablauf}

\subsection{Registrierung}
Bevor das eigentliche Spiel stattfindet registriert sich der User Agent bei einem voreingestellten Registrar. Dazu sendet er seine Anmeldung gemäß im Kapitel 3 vorgestellten Registrierungsprozess. Ist die Registrierung abgeschlossen ist der Registrar in der Lage diesen Spieler erfolgreich zu lokalisieren.

\subsection{NAT Traversal}
Dadurch, dass SIP mit dem STUN Protokoll arbeitet sind wir in der Lage im Spiel auch mit Rechnern zu verbinden die hinter einem Router liegen. Dazu wird bei der Registrierungsphase ein öffentlicher STUN Server angegeben, der dann kontaktiert wird und dem Spieler erlaubt seine öffentliche IP Adresse und den Typ des eingesetzten Routers herauszufinden. 

\subsection{Spieler startet das Spiel}
Im Startbildschirm sieht der Spieler alle seine bisherigen Freunde und kann sofort ihren Status sehen: Freunde können entweder offline sein, online sein oder im Spiel. Will der Spieler das Spiel betreten kann er einen aktiven Spieler anwählen und Join klicken. Möchte er ein neues Spiel starten kann er mittels Create ein Neues Spiel anlegen.

\subsection{Neuer Spieler betritt das Spiel}
Betritt ein neuer Spieler das Spiel, so wird er nicht nur von der Irrlicht Engine im Spiel dargestellt sondern auch in die lokale Buddyliste des Spielers aufgenommen. Alle Spieler der Buddyliste sind potenzielle Kandidaten für eine Sprachkommunikation. Diese wird, falls sich der Spieler in entsprechender Nähe befindet in der VoIP Instanz ausgeführt.

\subsection{Spieler beendet sein Spiel}
Beendet ein Spieler sein Spiel, so bedeutet es für die übrigen Spieler nicht, dass das komplette Spiel auch beendet ist. Das verlassen eines Spielers hat die einzige Auswirkung, dass dieser Spieler keine Positionsinformationen mehr versendet und empfängt und dass alle aktiven Gespräche mit diesem Spieler beendet werden.
