\chapter{SIP als Netzwerkgrundlage in Spielen}

\section{SIP als Netzwerkschicht}
Wie schon im Kapitel 5 beobachtet, sind die Herausforderungen an die Verwaltung eines Spieles mit der darunter liegenden Netzwerkarchitektur verbunden. So haben wir uns in Kapitel 5 und 6 ausführlich mit dem der Evaluation, Entwurf und Umsetzung verschiedener Architekturen und ihrer Tauglichkeit für die Sprachkommunikation auseinander gesetzt und wollen zum Schluss zeigen wie SIP zusätzlich auch als Netzwerkschicht verwendet werden kann. 

Da SIP ein generisches Protokoll ist, ist es prinzipiell nicht nur für die Sprachkommunikation einsetzbar sondern auch um Daten zwischen Clients auszutauschen. Dabei wollten wir prüfen welche der bestehenden Architekturen sich mit SIP umsetzen lassen. Experimentell haben wir eine einfache Client-Server Architektur implementiert, die aus dem Prototypen somit ein völlig auf dem SIP Protokoll basiertes Spiel macht. Dabei wollen wir nicht bestehende Probleme der einzelnen Architekturen lösen indem wir das SIP Protokoll verwenden, sondern zeigen das SIP es uns ermöglicht bestehende Architekturen umzusetzen. Der resultierende Vorteil besteht vor allem in einer standardisierten Addressierung,  Signalisierung und hoher Abstraktionsebene.

\section{Anforderungen an die Netzwerkschicht}

Mehrspieler Spiele besitzen vielfältige Anforderungen an eine Netzwerkarchitektur. Abhängig von der gewählten Architektur lassen sich einige der Anforderungen leichter umsetzen als andere.

\textbf{Sicherheit:} Dadurch dass Spieler gegeneinander antreten, sollte Manipulation ausgeschlossen werden. Dazu benötigt man eine sichere Kommunikation zwischen den Spielern. 

\textbf{Persistenz:} Dadurch dass der Inhalt des Spieles Spieler und Objekte enthalten kann die genau nur einmal existieren, muss zwischen den einzelnen Sitzungen dafür gesorgt werden dass diese persistent gespeichert werden.

\textbf{Zuverlässigkeit:} Durch einen zu häufigen Ausfall des Spielesystems, wird die Erfahrung des Spielens negativ beeinflusst. 

\textbf{Konsistenz:} Um eine sinnvolle Interaktion zwischen Spielern zu ermöglichen, muss die Erfahrung dieser Welt für jeden Mitspieler konsistent sein. Dies beinhaltet das Aufrechterhalten von Spielezuständen und die Synchronisation von Ereignissen. Um eine Konsistenz der Spielewelt zu Erreichen müssen Ereignisse der Spieler mittels Nachrichten im System ausgetauscht werden. 

\textbf{Durchsatz:} Dadurch dass viele Spiele die echte Welt simulieren, hat der Durchsatz des Systems großen Einfluss darauf wie Echt diese Illusion wahrgenommen wird. Werden durch große Verzögerungen Ereignisse verzögert dargestellt, so wird die Spielmechanik gestört. 

\textbf{Skalierbarkeit:} Eine skalierbare Architektur sollte sowohl eine große Anzahl an gleichzeitigen Benutzern, als auch einen starken Anstieg der Benutzer unterstützen, ohne dass die Last des Systems dramatisch ansteigt. 

Während Client- Server Basierte Systeme eine hohe Sicherheit, Persistenz und Konsistenz bieten ist ihre Zuverlässigkeit und Skalierbarkeit durch den einzelner zentralen Komponenten limitiert.Peer-to-Peer basierte Systeme dagegen bieten eine hohe Skalierbarkeit und Zuverlässigkeit sind aber Anfällig in ihrer Sicherheit, Persistenz und Performanz. 

In der Forschung werden beide Architekturen bezüglich der oben genannten Aspekte untersucht. So existieren vergleichende Studien \cite{lau06} bei denen Client-Server Systeme mit Peer-to-Peer Architekturen bezüglich ihrer Bandbreite, Last und des Delay in Simulationen verglichen wurden. Darüber hinaus wurden auch Inhalte des Netzwerkverkehrs in Spielen analysiert \cite{lau05b}, oder die Auswirkungen der geografische Verteilung von Spieleservern und Spielern untersucht \cite{feng03}. 


\section{Client - Server in Netzwerkspielen}
Die Client- Server-Architektur für Netzwerk Spiele war über Jahrzehnte die dominierende Architektur, die in der Lage war zwischen 2 und 64 Spieler gleichzeitig zu unterstützen \cite{singhal99}. Die Mehrheit kommerzieller Mehrspieler Spiele benutzt heutzutage eine zentralisierte Architektur. Diese wird auch in Zukunft die üblichste Architektur für Spiele mit einer kleinen Spieleranzahl bleiben, ist aber nicht in der Lage mehrere tausend gleichzeitige Spieler zu unterstützen. 

Obwohl einzelne Server dem System hinzugefügt werden können, steigt die Netzwerklast des Systems polynomiell mit der Zunahme von Spielern auf dem System \cite{lau06}.  Aufgrund dieser Tatsache bilden zentralisierte Server immer den Flaschenhals einer Netzwerkkommunikation. Da die Tendenz zum Spiel als Kommunikationsplattform (Massive Multiplayer Onlinge Game Abk. MMOG), bei der bis zu 10 Millionen Spieler in Spielergruppen miteinander spielen und kommunizieren \citep{wow2.2} geht und zentralisierte Systeme nicht über mehrere zehtausend Spieler skalierbar sind, verfehlen sie laut Marktanalysten ihr eigentliches Marktpotenzial \cite{thor03}. 

\subsection{Techniken zur Skalierung}

\subsubsection{Sharding}
Um das Problem der unzureichenden Skalierbarkeit zu umgehen wird von vielen Entwicklern das so genannte "`Sharding"' eingesetzt \cite{brandt05}. Ein "`Shard"' ist eine komplette und unabhängige Instanz der Spielewelt. Die maximale Anzahl an Spielern einer solchen Welt ist limitiert.  Durch das Hinzufügen von Shards können Entwickler zwar mehr Spieler aufnehmen, die aber in verschiedenen Spielewelten existieren und nicht miteinander interagieren können. Das derzeit größte MMOG \textit{World of Warcraft (WoW)} \cite{wow08} weltweit setzt erfolgreich Sharding ein um Spieler in mehreren gleichzeitig existierenden Spielewelten zu verwalten.

\subsubsection{Clustering}
Eine zusätzliche Möglichkeit besteht daraus Cluster von Computern einzusetzen die als gemeinsame Client- Server-Platform nach außen auftreten. Solche Systeme werden als Federated Client-Server Systeme bezeichnet. Diese Methode wird erfolgreich von Spielen wie EVE Online eingesetzt, die den Rekord für die größte Anzahl an gleichzeitigen Spielern auf einem Cluster mit 23000 Spielern hält \cite{brandt05}. Dabei ist jeder Computer in diesem Cluster ist für eine andere Portion der virtuellen Welt verantwortlich. Durch Load Balancing werden Spieler zwischen Computern im Cluster transferiert um die maximale Bandbreite und Last einer Maschine nicht zu überschreiten. Studien von Lau in denen das Client-Server Federating Simuliert wurde, zeigten jedoch, dass auch diese Technologie ihre Grenzen hat \cite{lau06}.

\subsubsection{Interest Management}
Um eine konsistente Spielewelt zu erzeugen, die performant und skalierbar ist wird in das Interest Management eingesetzt \cite{morse96}. Unter Interest Management versteht man, dass Individuen nur eine begrenzten Wahrnehmungsradius besitzen und nur an Dingen interessiert sind die in einer limitierten lokalen Umgebung geschehen, welche auch als Area of Interest bezeichnet wird. 

Eine übliche Technik im Interest Management besteht daraus die Spielewelt in Regionen aufzuteilen, wobei der Spieler immer nur Mitglied einer Region ist und auch nur Nachrichten dieser Region erhält. Interest Management ist in einer Client-Server Architektur sehr einfach umsetzbar, da der Server alle eingehenden Nachrichten vor dem weiterleiten filtern kann, was jedoch in einem P2P System nicht ohne weiteres möglich ist, da keine solche zentrale Komponente existiert \cite{yu05}.

\section{SIP im Client-Server Modus}
In der Implementierung einer SIP Netzwerkarchitektur wurde versucht bereits bestehende Komponenten einzusetzen. Proxy und Registrar sind hier als eine Einheit zu verstehen, die SIP Server genannt wird. Der SIP Server wurde dazu eingesetzt um die Registrierung der Benutzer vorzunehmen und alle Nachrichten zu empfangen und weiterzuleiten an die entsprechenden Teilnehmer weiterzuleiten. 

%Abbildung die den Nachrichtenfluss zeigt. 
%Registrierung am Registrar
%Nachrichtenfluss mittels MESSAGE so eine Art Knotennetz oder sowas.

Hat sich ein Spieler erfolgreich auf dem Registrar angemeldet, werden alle Nachrichten an diesen Benutzer auf dem SIP Server aufgelöst und an den Client weitergeleitet. Dabei ist es prinzipiell sogar möglich ohne die Hilfe eines Registrars miteinander zu kommunizieren, falls die Spieler die gegenseitigen Adressen bereits kennen. 

Da die Entwicklung einer Spiellogik viele Aspekte unter anderem auch der Synchronisation, Konsitenz und Fairness enthält, die über den Rahmen der Arbeit hinausgehen, haben wir uns darauf konzentriert, zu zeigen wie das SIP Protokoll als Netzwerkschicht dazu genutzt werden kann Spielezustände auszutauschen. 

Dies wurde im Spiel auf den Clients so umgesetzt, dass jeder Teilnehmer in der Lage ist sich in einer 3D Umgebung zu bewegen, und mit den Gegenständen und Spielern eines Spieles zu kollidieren. Dabei informiert er alle anderen Spieler über seine Ereignisse.

\subsection{SIP SIMPLE Protokoll}

%                 A Framework for Conferencing with the
%                  Session Initiation Protocol (SIP)
% http://www.ietf.org/rfc/rfc4353.txt

Die Entscheidung das SIMPLE Protokoll als Untergruppe des SIP Protokolls zu benutzen ergibt sich aus den gleichen Gründen wie das SIP Protokoll. Es handelt sich um ein offenes, weit verbreitetes Protokoll für das viele open-source Implementierungen existieren. Auch der MSN Messenger, eines der am weitesten verbreiteten Instant Messenging Applikationen weltweit, beruht auf der Grundlage des SIP und SIMPLE Protokolls. 

\subsubsection{Nachrichtendienst}
Die SIP Clients nutzen das in Kapitel 3 vorgestellte SIP SIMPLE Protokoll um miteinander zu kommunizieren. Der Datenaustausch zwischen den Clients findet mit Hilfe des SIP MESSAGE Nachrichtentyps statt. 

Obwohl das SIP SIMPLE Protokoll ursprünglich vorgesehen wurde um Instant Messenging im SIP Standard analog zu vorhandenen Standards wie ICQ, Jabber zu ermöglichen, nutzen wir den es um Spieledaten auszutauschen. So enthalten Nachrichten außer Empfänger und Versender in ihrem Payload Teil Koordinaten der Spieler oder deren Status. 

Die Benutzung dieses Standards für unsere Zwecke ist deshalb möglich weil es sich auch hier um ein generisches Protokoll handelt, das für verschiedene Zwecke genutzt werden kann und sich somit auch für Datenkommunikation in Spielen nutzen lässt. 

Exemplarisch haben wir mehrere Nachrichtentypen generiert:
\begin{itemize}
	\item Position: Die Positionsnachricht enthält die aktuelle Position des Spielers im Spiel. Ihr Aufbau besteht aus der X, Y und Z Koordinate, denen die Buchstabenfloge COORD vorrausgeht.
	\item Status: 
\end{itemize}

Eine übliche Transaktion sieht folgendermaßen aus:

%           |  F1 MESSAGE          |                         |
%           |--------------------> |  F2 MESSAGE             |
%           |                      | ----------------------->|
%           |                      |                         |
%           |                      |  F3 200 OK              |
%           |                      | <-----------------------|
%           |  F4 200 OK           |                         |
%           |<-------------------- |                         |
%           |                      |                         |
%           |                      |                         |
%           |                      |                         |
%        User 1                  Proxy                    User 2

Die Grafik zeigt eine Nachricht die von Teilnehmer A and Teilnehmer B geschickt wurde, wobei beide Teilnehmer Teil der gleichen Domäne sind, und den gleichen Proxy benutzen. 
Der Grundlegende Unterschied zum SIP Protokoll besteht darauf dass es hier kein separater Medienstrom existiert. Die Textnachrichten werden in einem SIP Paket über die Knoten übertragen die den Signalisierungspfad bilden. Dies erfordert eine größeres Bedürfniss nach Sicherheit als bei anderen SIP Anfragen da der der Benutzer allen dem Proxy vertrauen muss. Unverschlüsselte Nachrichten liegen diesem offen und auch eventuelles Forking ohne Wissen des Benutzers ist hier möglich. 



\subsubsection{Buddy Konzept}
Spieler wählen einen Benutzernamen, der auch ihrer SIP Adresse entspricht. In einer Freundesliste halten sie Adressen alle Benutzer des Spieles vor, die auch Buddy Liste genannt wird. Mittels dieser Liste und des vorgestellten Präsenzdienstes sind Spieler in der Lage festzustellen welche Spieler Teil des Spiels sind. 

\subsubsection {Präsenzdienst}
Präsenz ist eine Begriff der im Instant Messenging verwendet wird und sich darauf bezieht ob Benutzer in der Lage sind festzustellen ob andere Benutzer verbunden sind, um dann benachrichtigt zu werden falls diese das online oder offline gehen. Zum Beispiel kann ein Benutzer eine Liste von Personen besizten mit denen er kommunizieren möchte. Solche benutzer werden "`Freunde"' oder englisch Buddies genannt. Der Präsenzdient erlaubt es einem Benutzer zu sehen ob ein Freund online gegangen ist, indem dieser zum Beispiel in der Liste farblich hervorgehoben wird. 

Generell dient der Proxy nur als Nachrichtenverteiler, dh. dass er selbst keinerlei Spielelogik enthält, sondern stattdessen alle Spieler dafür selbst verantwortlich sind anwesende Mitspieler mit allen relevanten Informationen über sich zu versorgen. Umgekehrt erwarten Teilnehmer, dass alle anderen Spieler sich genauso verhalten und sie mit ihren Informationen versorgen.

Durch dieses Vorgehen existiert kein spezieller Spieler, der das Spiel veranstaltet und steuert. So ist es möglich dass jederzeit Spieler das Spiel verlassen und betreten ohne  dass das aktuelle Spiel unterbrochen wird. 

Dazu müssen alle Teilnehmer in der Lage sein zu wissen welche andern Teilnehmer am aktuellen Spiel teilnehmen. Zu diesem Zweck wird der SUBSCRIBE/NOTIFY Mechanismus von SIP benutzt. Mittels des SIMPLE PRESENCE Dienstes, der auf diesem Mechanismus aufbaut sind Teilnehmer in der Lage die eigene Präsenz zu signalisieren und Präsenzen anderer Teilnehmer zu abonnieren. Anhand der Präsenzinformation werden Nachrichten nur an Spieler versendet die eine Teilnahme am Spiel signalisieren. 

Dabei haben wir drei verschiedene Präsenzstati definiert:
\begin{itemize}
	\item Offline - Der Spieler ist nicht an einem Registrar angemeldet und kann auch nicht kontaktiert werden. 
	\item Online - Der Spieler hat sich an einem Registrar angemeldet, nimmt aber momentan nicht am Spiel teil.
	\item Im Spiel - Der Spieler hat sich am Registrar angemeldet und nimmt gerade am Spiel teil.
\end{itemize}

Eine übliche Presence-Subscribe Verbindung findet folgendermaßen statt:
%BILD Presence
%   Watcher             Server                 PUA
%      | F1 SUBSCRIBE      |                    |
%      |------------------>|                    |
%      | F2 200 OK         |                    |
%      |<------------------|                    |
%      | F3 NOTIFY         |                    |
%      |<------------------|                    |
%      | F4 200 OK         |                    |
%      |------------------>|                    |
%      |                   |                    |
%      |                   |   Update presence  |
%      |                   |<------------------ |
%      |                   |                    |
%      | F5 NOTIFY         |                    |
%      |<------------------|                    |
%      | F6 200 OK         |                    |
%      |------------------>|                    |

\subsection{Skalierbarkeit}
Um das Konzept des Sharding umzusetzen, kann bei einem solcher Aufbau für jede Spielewelt ein zentralen Registrar eingesetzt werdem, der eine maximale Anzahl an Spielern erhält. Möchte man Clustering einsetzen, so ist vorstellbar, dass für eine Region der Spielwelt jeweils ein Registrar eingesetzt wird, an dem sich die Clients anmelden und Nachrichten der Spieler empfangen die am gleichen Registrar angemeldet sind. Um Interestmanagement umzusetzen, können beim Registrar Nachrichten gefiltert werden, oder Clients autonom entscheiden an welche Teilnehmer sie Nachrichten versenden möchten.

\subsection{Tauglichkeit als Peer-to-Peer Ansatz}
Der von uns implementierte Ansatz braucht einzig die zentrale Komponente des Registrars, der für die Lokation der Teilnehmer verantwortlich ist. Wie wir später zeigen lässt sich diese SIP Komponente verteilt realisieren, was es uns ermöglichen könnte SIP als eine Netzwerkgrundlage für Peer-to-Peer Spiele zu nutzen.

\section{Peer-to-Peer}
In den letzten Jahren sind Peer-to-Peer Netzwerke ein wichtiger Gegenstand der Forschung geworden \cite{lua05}. Ihr größter Vorteil gegenüber zentralisierten Architekturen ist ihre Skalierbarkeit. Jeder Knoten der dem System beitritt und Anfragen stellt, muss dem System gegenüber auch Ressourcen freigeben und Anfragen anderer Knoten bearbeiten. Knoten die mehr Dienste zur Verfügung stellen werden als SuperPeers oder Koordinatoren bezeichnet. Dabei wird eine Gruppe von Knoten als Overlay bezeichnet und die konstante Veränderung der Teilnehmer als Churn. Es existieren P2P Systeme die bis zu mehreren Millionen an gleichzeitigen Benutzern skalieren \cite{stutzbach05}. 

\subsection{Distributed Hash Tables}
Als verteilte Hashtabelle (Distributed hash table (DHT)) versteht man eine Datenstruktur, die versucht das allgemeine Problem in P2P-Systemen – den Speicherort einer gesuchten Datei zu finden – mit möglichst geringem Aufwand effizient zu lösen. Dabei sollten die Datenobjekte möglichst gleichmäßig über die Knotenmenge verteilt und ein von jedem beliebigen Einstiegsort ortsunabhängiges Routing zum verantwortlichen Knoten ermöglicht werden. Jeder Knoten ist dabei analog zu einem Behälter einer Hashtabelle. Die Datenstruktur muss ständige Anpassungen durch Ausfall, Beitritt und Austritt von Knoten überstehen, sich selbst organisieren und skalierbar sein. Die Grundlage für verteilte Hashtabellen bilden konsistente Hash-Funktionen.

Dazu werden einheitliche zufällige Hash IDs in einem Set von Knoten in einem großen Bezeichnungsraum vergeben. Objekten eindeutige einheitliche Schlüssel aus dem gleichen Namensraum zugeteilt. Es existieren folgende Implementierungen verteilter Hashtabellen, CAN \cite{Ratnasamy01},Chord \cite{Stoica01}, Pastry \cite{Rowstron01} und Tapestry \cite{zaho01} die sich durch spezielle Eigenschaften voneinander unterscheiden, deren Erläuterung jedoch hier nicht Thema der Arbeit ist. 

\subsection{Peer-to-Peer in Netzwerkspielen}
Im Kontext von Netzwerkspielen, kann jeder Spieler als ein P2P Knoten angesehen werden, der Ressourcen im System freigibt. In der Forschung finden sich erste Anfänge im P2P Spiel MiMaze, in dem durch Spieler über Ereignisse Mittels IP multicasting benachrichtigt werden \cite{diot99}. 

Grunsätzlich lassen sich Peer-to-Peer Systeme in unstrukturierte Systeme und strukturierte Systeme unterscheiden\cite{lau05w}. Unter unstrukturierten Systemen wird das P2P Overlay in dem die Topologie einer zufälligen Organisation entspricht und der Inhalt Mittels verschiedener Suchverfahren die das Overlay durchqueren lokalisiert wird. Dazu analysiert jeder Knoten die Suchanfrage und leitet sie weiter falls er den gewünschten Inhalt nicht finden kann, was zu einer uneffizienten Lokalisierung führt.

Unter einem strukturiertem System versteht man ein P2P Overlay, in dem die Topologie fest kontrolliert wird und der Inhalt nicht bei zufälligen Knoten plaziert wird, sondern an speziellen ausgewählten Knoten existiert, um seine Lokalisierung mittels DHT effizienter zu ermöglichen. 

Douglas schlägt in \cite{douglas05} vor, P2P Netzwerk Spiel Architekturen in nachbarbasierte oder regionsbasierte Systeme zu unterscheiden, wobei nachbarbasierte Systeme in die Kategorie der unstrukturierten Systeme fallen und regionsbasierte Systeme zu den strukturierten Systemen gehören.

\subsection{Nachbarbasierte P2P-Systeme}
Nachbarbasierte Systeme bestehen aus Knoten mit gleicher Verantwortung, bei der jeder Knoten seine Nachbarn über Ereignisse informiert. Die benötigte Bandbreite ist eine Funktion der Dichte der Avatare. Solche Systeme besitzen gute skalierungseigenschaften, können jedoch von einer Partitionierung des Netzwerks leiden \cite{Keller03}. Ein Beispiel für Partitionierung ist, wenn eine Knoten sich in die Nähe eines anderen Knoten begibt aber keiner der Knoten über diese Änderung informiert wird, was letzendlich zu einer fehlerhaften Spielmechanik führt.  Ein weiteres Problem ist generell die ineffiziente Nutzung der vorhandenen Ressourcen.

In Kawaharas' "`Peer-to-Peer Message Exchange Scheme"'  Ansatz werden zwischen unmittelbar benachbarten Knoten Nachbarschaftslisten ausgetauscht. Dabei steigt die Größe der ausgetauschten Nachrichten mit $O(N^{2})$, wobei $N$ die Anzahl der Nachbarn darstellt \cite{kawahara02}. Dadurch, dass nur unmittelbare Nachbarn Nachrichten austauschen kann für isolierte Gruppen, die sich weit von anderen Gruppen befinden, eine Partitionierung auftreten. 

In Kellers' Solipsis Ansatz agiert jeder Knoten als Beobachter der benachbarten Knoten. 
Jeder Teilnehmer beobachtet jede Bewegung seiner Nachbarn und benachrichtigt andere Teilnehmer, wenn neue Nachbarn für ihn entdeckt wurden. Im Gegensatz zu Kahawaras Ansatz verbindet sich hier der Teilnehmer nicht unbedingt mit seinen nächsten Nachbarn
\cite{Keller03}.

\subsubsection{Voronoibasierte P2P Systeme}
In Voronoibasierten Systemen ermittelt jeder Knoten Anhand eines Voronoi Diagramms  seine direkten Nachbarn. Mit allen Nachbarn hält der Knoten Verbindungen aufrecht. 
Im Voronoi Schema von Hu aktualisiert jeder Teilnehmer bei jeder seiner Bewegungen seine Nachbarn. Nachbarn, die sich an der Grenze der Area of Interest befinden überprüfen wiederum ob der Knoten sich in den Bereich ihrer Nachbarn bewegt und versorgen diese mit neuen Topologieinformationen\cite{hu04}. 

\subsection{Regionsbasierte P2P-Systeme}
Regionsbasierte Systeme unterteilen die Welt in geometrische Formen wie Quadrate oder Sechsecke. Regionen können dabei dynamisch oder statisch sein, der Einfachheit halber werden oft statische Regionen eingesetzt. Für jede Region wird ein Koordinator oder Superpeer bestimmt. Dieser Knoten verwaltet Spieler die diese Region betreten und verlassen. Solche Regionen sind dafür verantwortlich, worüber der Spieler informiert wird - alle Ereignisse die in einer Region generiert werden, werden auch nur an Knoten der gleichen Region propagiert. Die einzige Ausnahme bildet der Fall, wenn sich eine Knoten von einer Region in die nächste bewegt und so Ereignisse des Knotens an zwei Regionen propagiert werden. Dabei muss der Koordinator einer solchen Region nicht unbedingt Teilnehmer des aktiven Spiels sein. Das ermöglicht den einsatz von dedizierten Rechnern mit großen Kapazitäten die speziell nur diesen Zweck erfüllen. Regionsbasierte Systeme benutzen verteilte Hash Tabellen ( Distributed Hash Tables (DHT)) um weitere Knoten zu finden. 

Die Regionsgröße ein wichtiger Faktor, wenn man eine regionsbasierte Architekturen entwirft. Einerseits führt eine Verkleinerung der Region dazu, dass weniger Ereignisse verwaltet und gesendet werden müssen. Andererseits führen zu kleine Regionen dazu, dass Avatare schnell zwischen Regionen wechseln und so zusätzliche Nachrichten an benachbarte Regionen gesendet werden müssen. 

Studien \cite{knutsson04} von Knutsson, Lu, Xu und Hoptkins in denen die DHT Architektur auf ihren Einsatz in Mehrspieler Spielen untersucht wurde haben gezeigt, dass die Erzeugung einer übergangsloser Welt problematisch sein kann, da bei Übergängen von einem Koordinator zum Nächsten Avatare kurzzeitig nicht mit den nötigen Informationen über die neue Region versorgt werden. Im Spiele Prototyp SimMud, zeigen Sie dass Spieler indem sie auch die Informationen von benachbarten Regionen abonnieren, nahtlose Übergänge zwischen den einzelnen Regionen ermöglicht werden . 


Limura, Hazeyama und Kadobayashi \cite{Iimura04} unterteilen die Spielewelt in Spiele Zonen, von denen jede mittels Koordinatoren verwaltet wird. Koodinatoren sind Teil einer "`Föderation"' von Koordinatoren, die alle untereinander Spielezustände mittels DHT austauschen. Dabei dient DHT für Spieler , die neu hinzukommen oder sich bewegen, dazu um ihren zuständigen Koordinator zu finden. Die Kommunikation zwischen Spielern immer ausschließlich Mittels eines Koordinators statt. 

Triebel, Guthier und Effelsberg schlagen in \cite{triebel07g} den Einsatz vom propriäteren Skype Protokoll vor, um Spieledaten auszutauschen. Dazu unterteilen sie die Spielewelt in mehrere Regionen denen Spieler angehören können. Aktionen der Spieler in der gleichen Region, werden ebenfalls nur Spieler der gleichen Region weitergeleitet.
Dabei wird für jede Region mit Hilfe der Skype Chatraum Funktion festgehalten welche Spieler dieser Region angehören. In einer Evaluation des Verfahrens erreichen sie durchgehen akzeptable Latenzen unter 300ms, die zeigen dass der Einsatz von Skype für skalierbare Mehrspieler Spiele möglich ist. 

\subsection{Hybride P2P-Systeme}
In Hybriden Systemen werden beide Methoden gleichzeitig eingesetzt, so werden Vorteile von strukturieren Overlays wie DHT mit denen von unstrukturierten P2P Architekturen verbunden. Zunächst bestimmt ein Knoten seine Nachbarn mit Hilfe des Koordinators. Diese kontaktiert direkt ohne die Hilfe des Koordinators.  

Im strukturierten Teil des Hybriden Ansatzes von Yu \cite{yu05} werden Knoten in Master, Slave und Home knoten unterteilt, bei denen Regionen mittels der Master-Knoten verwaltet werden. Mittels der ihrer Home-Knoten Masterknoten sich untereinander verbinden und Slave-Knoten von  ihren Masterknoten verwaltet werden. Im Unstrukturieren Teil tauschen die die Master-Knoten untereinander Mittels Listen Informationen über ihre Nachbarn untereinander aus. Das System versucht so einerseits eine Partitionierung des Netzwerks zu verhindern, während der zusätzliche Netzwerkverkehr der durch die Verwendung von DHT entsteht Minimiert werden soll.

%TODO TABLE

\section{Hybride Systeme}
Hybride P2P Systeme benutzen einen zentralisierten Server um einen bestimmten Knoten der einen Service anbietet zu lokalisieren. Der Service selbst wiederum, findet direkt zwischen den Knoten statt. Das beste Beispiel eines hybriden P2P Systems sind online Dateitauschdienste wie z.B. das Torrent Protokoll. Jeder Knoten veröffentlicht seine eine Liste seiner Dateien an einen zentralen öffentlichen Server. Ein Benutzer der nach einer speziellen Datei sucht, kontaktiert zunächst den öffentlichen Server um den Knoten herauszufinden, der Dateiaustausch selbst findet zwischen den einzelnen Knoten statt. Ein anderes Beispiel ist das SIP Protokoll zur Internet-Telefonie in dem einzelne öffentliche Server die Lokalisierung und Verwaltung der Benutzer vornehmen, das Telefongespräch selbst, aber zwischen den Knoten selbst stattfindet.

\section{Peer-to-Peer SIP}
\subsection{Motivation für Peer-to-Peer SIP}
Da SIP bereits als Standard etabliert ist hat auf dem Technologien Aufsetzen können und viele Eigenschaften besitzt die es Attraktiv für einen reinen Peer-to-Peer Betrieb attraktiv machen, bestehen seit dem Jahr 2005 Bemühungen das Hybride SIP Protokoll komplett zu einem reinen Peer-to-Peer Protokoll zu erweitern. Dabei ist das Interesse sehr hoch, da Mittlerweile bereits über dutzende Entwürfe zur Realisierung eines Standards bei der IETF eingegangen sind \cite{bryan07}. Der große Vorteil gegenüber anderen Systemen ist die Kombination von bereits etablierten Standards wie dem SIP und SIMPLE Protokoll \cite{rosenberg02} für Voice Over IP und Instant Messaging mit Eigenschaften von Distributed Hash Tables. Dadurch, dass bisher in P2P Systemen noch keine Standards existieren bietet sich die Verwendung von SIP, das als ausgereift und etabliert gilt, für diesen Zweck an. Zusätzlich sind viele Endgeräte wie Firewalls und Router bereits in der Lage SIP Netzwerkverkehr zu erkennen und zu unterstützen. 

SIP ist konventionell so gestaltet, dass so viel Funktionalität wie möglich in den Endpunkten enthalten ist. So werden alle Nachrichten die für den Aufbau eines Telefongesprächs, oder dem Austausch von Nachrichten notwendig sind bereits nur zwischen nur zwischen den Endpunkten ausgetauscht. Das Verhandeln des Mediacodecs und der Fähigkeiten der einzelnen User Agents findet ebenfalls direkt zwischen den Endpunkten statt. Ist ein Telefongespräch etabliert, so fließen die Daten zwischen direkt zwischen den Teilnehmern, zwei UA können auch so konfiguriert werden, dass sie direkt miteinander völlig ohne Server kommunizieren.
Der einzige zentralisierte Baustein in SIP besteht aus der Lokation der Ressourcen, beim Registrar. In einer gewöhnlichen SIP Konfiguration meldet sich jeder Endpunkt bei einem Registrar an, der eine Zuordnung zwischen dem Namen des Teilnehmers und seiner IP Adresse herstellt. Möchte nun ein Benutzer einen anderen anrufen, so kontaktiert er zunächst den SIP Proxy um die Zieladresse herauszufinden.

\subsection{Funktionsweise}
Als Peer-to-Peer SIP kann verstanden werden, dass die einzige zentrale Komponente des Systems entfernt wird und dezentral zwischen den einzelnen Teilnehmern verteilt realisiert wird. Dazu müssten die einzelnen Knoten die Funktion des Registrars übernehmen. Dabei fungiert jedes Telefon als ein Knoten im Overlay. Dem Telefon wir eine PeerID zugewiesen, die ein eindeutiger Hash aus seiner IP Adresse sein kann. Der Name des Benutzers des Telefons wird ebenfalls als ein eindeutiger Hash in der ResourceID gespeichert. Dabei ist jeder Knoten für die Speicherung eines Teils der gesammten Information zuständig. 

Im Fall von DHT wird nun eine Nachricht an den Knoten mit der geringsten Entferung der PeerID zur RessourceID weitergeleitet aus einer Liste von bekannten Knoten weitergeleitet. Dieses Verfahren wird so lange wiederholt bis es beim Knoten mit der geringsten Enterfnung endet. 

Möchte ein Telefon dem Overlay beitreten so ermittelt es seine PeerID und versucht nun durch Austausch von Nachrichten seinen Platz im Overlay zu bestimmen. Wird es teil des Overlay so wird es auch für einen Teil der Informationen verantwortlich, dabei übernimmt es Informationen vom Knoten der bisher für den Lokalisationsraum zuständig war. Als nächstes wird aus dem Namen des Teilnehmers eine RessourceID gebildet. In einer Nachricht die die RessourceID und den Namen des Teilnehmers beinhaltet registriert sich der Knoten nun am Netz. Im konventionellen SIP würde diese Nachricht an einen zentralen Server weitergeleitet werden, hier jedoch wird die Nachricht so lange vom Overlay weitergeleitet bis sie ihren Zielort erreicht, wo sie von einem Knoten gespeichert wird. 

Möchte ein Benuter nun einen anderen Benutzer anrufen so wird eine Suchanfrage die die RessourcenID beinhaltet an das Overlay gestellt, diese wird durch das Netz geleitet bis der Knoten gefunden wird der die entsprechende IP Adresse enthält. Dieser Knoten beantwortet die Anfrage und der Benutzer kann nun direkt Mittels SIP direkt mit dem Zielknoten kommunizieren. 

Verlassen Knoten das Overlay so müssen sie ihre Information an andere Knoten weitergeben, oft wird die Information auch mehrfach repliziert um Datenverlust zu vermeiden. 
%TODO Graphics 

Bryan, Lowekamp und Jennings schlagen im SOSIMPLE Prototyp eine Kombination vom SIP und SIMPLE Protokoll vor in dem Knoten mittels eines auf Chord basierten DHT \cite{bryan05s} in einem Overlay verwaltet werden. Dabei sind alle Nachrichten die benötigt werden um das DHT aufrechzuerhalten, Benutzer zu Registrieren, Ressourcen zu lokalisieren, Sitzungen zu verwalten reine SIP Nachrichten. Dadurch das SIP als generisches Protokoll entworfen wurde müssen keine neuen Methoden hinzugefügt werden sondern die Nachrichtentypen um zusätzliche Header ergänzt werden. 

Alternativ analysieren Singh und Schulzrinne verschiedene VoiP Peer-to-Peer Alternativen und schlagen ebenfalls ein Konzept für P2P basierte SIP Telefonie auf Basis eines Chord basierten DHT vor \cite{schulzrinne05}.


\subsection{Architektur Variationen}
Es bestehen drei alternative Architektur Möglichkeiten im Einsatz mit DHT. 

% TODO BILD.

Wir können den DHT auf eine Server Farm limitieren, in der jeder Teilnehmer zu einem der Server verbindet. Die Server selbst implementieren eine skalierbare Datenstruktur wie DHT um den entsprechenden Eintrag zu finden. Diese Architektur ist jedoch immer noch Client Server basiert. Der Teilnehmer muss mindestens einen Server finden und zu ihm verbinden. Diese Option beinhaltet keine Modifizierung der Clients, bietet aber eine zuverlässige Server Farm Architektur. 

Eine andere Möglichkeit ist dass jeder Client auch als Server arbeitet. Das Problem hierbei ist dass nicht alle Knoten eine gleiche Verfügbarkeit und Bandbreiten Kapazität besitzen. Ein Knoten mit geringer Bandbreite und einer schlechten Anbindung z.B. hinter einer NAT besitzt eventuell nicht ausreichend im DHT funktionieren. 

Im dritten Ansatz kann eine Mischung aus den zwei Ansätzen gewählt werden in der Knoten mit hoher Kapazität  (Bandbreite, CPU, Speicher) und Verfügbarkeit (öffentlich Erreichbar) zu SuperNodes (Koordinatoren) erkoren werden. Diese Koordinatoren Formieren die DHT. Dabei entscheidet jeder Knoten aufgrund seiner Eigenschaften selbst ob eine SuperNode werden will oder nicht. 