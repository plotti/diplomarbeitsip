\chapter{SIP als Netzwerkgrundlage in Spielen}

\section{SIP als Netzwerkschicht}
Wie schon im Kapitel 5 beobachtet, sind die Herausforderungen an die Verwaltung eines Spieles mit der darunter liegenden Netzwerkarchitektur verbunden. So haben wir uns in Kapitel 5 und 6 ausführlich mit dem der Evaluation, Entwurf und Umsetzugn eines verschiedener Architekturen und ihrer Tauglichkeit für die Sprachkommunikation auseinander gesetzt. 

Da SIP ein generisches Protokoll ist, ist es prinzipiell nicht nur für die Sprachkommunikation einsetzbar sondern auch um Daten zwischen Clients auszutauschen. Dabei wollten wir prüfen welche der bestehenden Architekturen sich mit SIP umsetzen lassen. Experimentell haben wir eine einfache Client-Server Architektur implementiert, die aus dem Prototypen somit ein völlig auf dem SIP Protokoll basiertes Spiel macht. 

\section{Anforderungen an die Netzwerkschicht}

Mehrspieler Spiele besitzen vielfältige Anforderungen an eine Netzwerkarchitektur:

\textbf{Sicherheit:} Dadurch dass Spieler gegeneinander antreten, sollte Manipulation ausgeschlossen werden. Dazu benötigt man eine sichere Kommunikation zwischen den Spielern. 

\textbf{Persistenz:} Dadurch dass der Inhalt des Spieles Spieler und Objekte enthalten kann die genau nur einmal existieren muss zwischen den einzelnen Sitzungen dafür gesorgt werden dass diese persistent gespeichert werden.

\textbf{Zuverlässigkeit:} Durch einen zu häufigen Ausfall des Spielesystems, wird die Erfahrung des Spielens negativ beeinflusst. 

\textbf{Konsistenz:} Um eine sinnvolle Interaktion zwischen Spielern zu ermöglichen, muss die Erfahrung dieser Welt für jeden Mitspieler konsistent sein. Dies beinhaltet das Aufrechterhalten von Spielezuständen und die Synchronisation von Ereignissen. Um eine Konsistenz der Spielewelt zu Erreichen müssen Ereignisse der Spieler mittels Nachrichten im System ausgetauscht werden. 

\textbf{Durchsatz:} Dadurch dass viele Spiele die echte Welt simulieren, hat der Durchsatz des Systems großen Einfluss darauf wie Echt diese Illusion wahrgenommen wird. Werden durch große Verzögerungen Ereignisse verzögert dargestellt, so wird die Spielmechanik gestört. 

\textbf{Skalierbarkeit:} Eine skalierbare Architektur sollte sowohl eine große Anzahl an gleichzeitigen Benutzern, als auch einen starken Anstieg der Benutzer unterstützen, ohne dass die Last des Systems dramatisch ansteigt. 

Dabei sind diese Aspekte unterschiedlich schwer zu realisieren in Abhängigkeit der gewählten Netzwerkarchitektur. Während Client- Server Basierte Systeme eine hohe Sicherheit, Persistenz und Konsistenz bieten ist ihre Zuverlässigkeit und Skalierbarkeit durch den einzelner zentralen Komponenten limitiert.
Peer-to-Peer basierte Systeme dagegen bieten eine potenziell hohe Skalierbarkeit und Zuverlässigkeit sind aber Anfällig in ihrer Sicherheit, Persistenz und Performanz. 

In der Forschung werden beide Architekturen bezüglich der oben genannten Aspekte untersucht. So existieren vergleichende Studien \cite{lau06} bei denen Client-Server Systeme mit Peer-to-Peer Architekturen bezüglich ihrer Bandbreite, Last und des Delay in Simulationen verglichen wurden. Darüber hinaus wurden auch Inhalte des Netzwerkverkehrs in Spielen analysiert \cite{lau05b}, oder die geografische Verteilung von Spieleservern und Spielern untersucht \cite{feng03}. 


\section{Client - Server in Netzwerkspielen}
Die Client- Server-Architektur für Netzwerk Spiele war über Jahrzehnte die dominierende Architektur, die in der Lage war zwischen 2 und 64 Spieler gleichzeitig zu unterstützen \cite{singhal99}. Die Mehrheit kommerzieller Mehrspieler Spiele benutzt heutzutage eine zentralisierte Architektur und diese wird auch in Zukunft die üblichste Architektur für Spiele mit einer kleinen Spieleranzahl bleiben, ist aber nicht in der Lage mehrere tausend gleichzeitige Spieler zu unterstützen. 
Obwohl einzelne Server dem System hinzugefügt werden können, steigt die Netzwerklast des Systems polynomiell mit der Zunahme von Spielern auf dem System.\cite{lau06}.  Aufgrund dieser Tatsache bilden zentralisierte Systeme immer den Flaschenhals einer Netzwerkkommunikation. Da zentralisierte Systeme nicht über mehrere zehtausend Spieler skalierbar sind, verfehlen sie ihr eigentliches Marktpotenzial \cite{thor03}. 

Um das Problem der unzureichenden Skalierbarkeit zu umgehen wird von vielen Entwicklern das so genannte "`Sharding"' eingesetzt \cite{brandt05}. Ein "`Shard"' ist eine komplette und unabhängige Instanz der Spielewelt. Die maximale Anzahl an Spielern einer solchen Welt ist limitiert.  Durch das Hinzufügen von Shards können Entwickler zwar mehr Spieler aufnehmen die aber in verschiedenen Spielewelten existieren und nicht miteinander interagieren können. \textit{World of Warcraft (Wow)} ist das größte MMOG derzeit, das mit über 10 Millionen Nutzern weltweit, und bis zu mehreren tausend Benutzern gleichzeitig betrieben wird. \cite{wow08} und auch Sharding einsetzt.

Eine zusätzliche Möglichkeit besteht daraus Cluster von Computern einzusetzen die als gemeinsame Client- Server-Platform nach außen auftreten. Solche Systeme werden als Federated Client-Server Systeme bezeichnet. Diese Methode wird erfolgreich von Spielen wie EVE Online eingesetzt, die den Rekord für die größte Anzahl an gleichzeitigen Spielern auf einem "`Shard"' mit 23000 hält \cite{brandt05}. Dabei ist jeder Computer in diesem Cluster ist für eine andere Portion der virtuellen Welt verantwortlich. Durch Load Balancing werden Spieler zwischen Computern im Cluster transferiert um die maximale Bandbreite und Last einer Maschine nicht zu überschreiten. Studien von Lau in denen das Client-Server Federating Simuliert wurde, zeigten jedoch, dass auch diese Technologie ihre Grenzen hat \cite{lau06}.

Um eine konsistente Spielewelt zu erzeugen die performant und skalierbar ist wird in das Interest Management eingesetzt \cite{morse96}. Unter Interest Management versteht man dass Individuen nur eine begrenzten Wahrnehmungsradius besitzen und nur an Dingen interessiert sind die in einer limitierten lokalen Umgebung geschehen, welche als Area of Interest bezeichnet wird. Eine übliche Technik im Interest Management besteht daraus die Spielewelt in Regionen aufzuteilen, wobei der Spieler immer nur Mitglied einer Region ist und auch nur Nachrichten dieser Region erhält. Interest Management ist in einer Client-Server Architektur sehr einfach, da der Server durch das Filtern von Nachrichten einfach, gestaltet sich jedoch in einem P2P System durchaus komplex \cite{yu05}.

\subsection{SIP im Client Server Modus}
\subsection{Registrar als Server}
\subsection{Clients}
\subsection{SIP Message Marshalling}


\section{Peer-to-Peer}
In den letzten Jahren sind Peer-to-Peer Netzwerke ein wichtiger Gegenstand der Forschung geworden \cite{lua05}. Ihr größter Vorteil gegenüber zentralisierten Architekturen ist ihre Skalierbarkeit. Jeder Knoten der dem System beitritt und Anfragen stellt, muss dem System gegenüber auch Ressourcen freigeben und Anfragen anderer Knoten bearbeiten. Knoten die mehr Dienste zur Verfügung stellen werden als SuperPeers oder Koordinatoren bezeichnet. Dabei wird eine Gruppe von Knoten als Overlay bezeichnet und die konstante Veränderung der Teilnehmer als Churn. Es existieren P2P Systeme die bis zu mehreren Millionen an gleichzeitigen Benutzern skalieren \cite{stutzbach05}. 

\subsection{Distributed Hash Tables}
Als verteilte Hashtabelle (Distributed hash table (DHT)) versteht man eine Datenstruktur, die versucht das allgemeine Problem in P2P-Systemen – den Speicherort einer gesuchten Datei zu finden – mit möglichst geringem Aufwand effizient zu lösen. Dabei sollten die Datenobjekte möglichst gleichmäßig über die Knotenmenge verteilt und ein von jedem beliebigen Einstiegsort ortsunabhängiges Routing zum verantwortlichen Knoten ermöglicht werden. Jeder Knoten ist dabei analog zu einem Behälter einer Hashtabelle. Die Datenstruktur muss ständige Anpassungen durch Ausfall, Beitritt und Austritt von Knoten überstehen, sich selbst organisieren und skalierbar sein. Die Grundlage für verteilte Hashtabellen bilden konsistente Hash-Funktionen.

Dazu werden einheitliche zufällige Hash IDs in einem Set von Knoten in einem großen Bezeichnungsraum vergeben. Objekten eindeutige einheitliche Schlüssel aus dem gleichen Namensraum zugeteilt. Es existieren folgende Implementierungen verteilter Hashtabellen, CAN \cite{Ratnasamy01},Chord \cite{Stoica01}, Pastry \cite{Rowstron01} und Tapestry \cite{zaho01} die sich durch spezielle Eigenschaften voneinander unterscheiden, deren Erläuterung jedoch hier nicht Thema der Arbeit ist. 

\subsection{Peer-to-Peer in Netzwerkspielen}
Im Kontext von Netzwerkspielen, kann jeder Spieler als ein P2P Knoten angesehen werden, der Ressourcen im System freigibt. In der Forschung finden sich erste Anfänge im P2P Spiel MiMaze, in dem durch Spieler über Ereignisse Mittels IP multicasting benachrichtigt werden \cite{diot99}. 

Grunsätzlich lassen sich Peer-to-Peer Systeme in unstrukturierte Systeme und strukturierte Systeme unterscheiden\cite{lau05w}. Unter unstrukturierten Systemen wird das P2P Overlay in dem die Topologie einer zufälligen Organisation entspricht und der Inhalt Mittels verschiedener Suchverfahren die das Overlay durchqueren lokalisiert wird. Dazu analysiert jeder Knoten die Suchanfrage und leitet sie weiter falls er den gewünschten Inhalt nicht finden kann, was zu einer uneffizienten Lokalisierung führt.

Unter einem strukturiertem System versteht man ein P2P Overlay, in dem die Topologie fest kontrolliert wird und der Inhalt nicht bei zufälligen Knoten plaziert wird, sondern an speziellen ausgewählten Knoten existiert, um seine Lokalisierung mittels DHT effizienter zu ermöglichen. 

Douglas schlägt in \cite{douglas05} vor, P2P Netzwerk Spiel Architekturen in nachbarbasierte oder regionsbasierte Systeme zu unterscheiden, wobei nachbarbasierte Systeme in die Kategorie der unstrukturierten Systeme fallen und regionsbasierte Systeme zu den strukturierten Systemen gehören.

\subsection{Nachbarbasierte P2P-Systeme}
Nachbarbasierte Systeme bestehen aus Knoten mit gleicher Verantwortung, bei der jeder Knoten seine Nachbarn über Ereignisse informiert. Die benötigte Bandbreite ist eine Funktion der Dichte der Avatare. Solche Systeme besitzen gute skalierungseigenschaften, können jedoch von einer Partitionierung des Netzwerks leiden \cite{Keller03}. Ein Beispiel für Partitionierung ist, wenn eine Knoten sich in die Nähe eines anderen Knoten begibt aber keiner der Knoten über diese Änderung informiert wird, was letzendlich zu einer fehlerhaften Spielmechanik führt.  Ein weiteres Problem ist generell die ineffiziente Nutzung der vorhandenen Ressourcen.

In Kawaharas' "`Peer-to-Peer Message Exchange Scheme"'  Ansatz werden zwischen unmittelbar benachbarten Knoten Nachbarschaftslisten ausgetauscht. Dabei steigt die Größe der ausgetauschten Nachrichten mit $O(N^{2})$, wobei $N$ die Anzahl der Nachbarn darstellt \cite{kawahara02}. Dadurch, dass nur unmittelbare Nachbarn Nachrichten austauschen kann für isolierte Gruppen, die sich weit von anderen Gruppen befinden, eine Partitionierung auftreten. 

In Kellers' Solipsis Ansatz agiert jeder Knoten als Beobachter der benachbarten Knoten. 
Jeder Teilnehmer beobachtet jede Bewegung seiner Nachbarn und benachrichtigt andere Teilnehmer, wenn neue Nachbarn für ihn entdeckt wurden. Im Gegensatz zu Kahawaras Ansatz verbindet sich hier der Teilnehmer nicht unbedingt mit seinen nächsten Nachbarn
\cite{Keller03}.

\subsubsection{Voronoibasierte P2P Systeme}
In Voronoibasierten Systemen ermittelt jeder Knoten Anhand eines Voronoi Diagramms  seine direkten Nachbarn. Mit allen Nachbarn hält der Knoten Verbindungen aufrecht. 
Im Voronoi Schema von Hu aktualisiert jeder Teilnehmer bei jeder seiner Bewegungen seine Nachbarn. Nachbarn, die sich an der Grenze der Area of Interest befinden überprüfen wiederum ob der Knoten sich in den Bereich ihrer Nachbarn bewegt und versorgen diese mit neuen Topologieinformationen\cite{hu04}. 

\subsection{Regionsbasierte P2P-Systeme}
Regionsbasierte Systeme unterteilen die Welt in geometrische Formen wie Quadrate oder Sechsecke. Regionen können dabei dynamisch oder statisch sein, der Einfachheit halber werden oft statische Regionen eingesetzt. Für jede Region wird ein Koordinator oder Superpeer bestimmt. Dieser Knoten verwaltet Spieler die diese Region betreten und verlassen. Solche Regionen sind dafür verantwortlich, worüber der Spieler informiert wird - alle Ereignisse die in einer Region generiert werden, werden auch nur an Knoten der gleichen Region propagiert. Die einzige Ausnahme bildet der Fall, wenn sich eine Knoten von einer Region in die nächste bewegt und so Ereignisse des Knotens an zwei Regionen propagiert werden. Dabei muss der Koordinator einer solchen Region nicht unbedingt Teilnehmer des aktiven Spiels sein. Das ermöglicht den einsatz von dedizierten Rechnern mit großen Kapazitäten die speziell nur diesen Zweck erfüllen. Regionsbasierte Systeme benutzen verteilte Hash Tabellen ( Distributed Hash Tables (DHT)) um weitere Knoten zu finden. 

Die Regionsgröße ein wichtiger Faktor, wenn man eine regionsbasierte Architekturen entwirft. Einerseits führt eine Verkleinerung der Region dazu, dass weniger Ereignisse verwaltet und gesendet werden müssen. Andererseits führen zu kleine Regionen dazu, dass Avatare schnell zwischen Regionen wechseln und so zusätzliche Nachrichten an benachbarte Regionen gesendet werden müssen. 

Studien \cite{knutsson04} von Knutsson, Lu, Xu und Hoptkins in denen die DHT Architektur auf ihren Einsatz in Mehrspieler Spielen untersucht wurde haben gezeigt, dass die Erzeugung einer übergangsloser Welt problematisch sein kann, da bei Übergängen von einem Koordinator zum Nächsten Avatare kurzzeitig nicht mit den nötigen Informationen über die neue Region versorgt werden. Im Spiele Prototyp SimMud, zeigen Sie dass Spieler indem sie auch die Informationen von benachbarten Regionen abonnieren, nahtlose Übergänge zwischen den einzelnen Regionen ermöglicht werden . 


Limura, Hazeyama und Kadobayashi \cite{Iimura04} unterteilen die Spielewelt in Spiele Zonen, von denen jede mittels Koordinatoren verwaltet wird. Koodinatoren sind Teil einer "`Föderation"' von Koordinatoren, die alle untereinander Spielezustände mittels DHT austauschen. Dabei dient DHT für Spieler , die neu hinzukommen oder sich bewegen, dazu um ihren zuständigen Koordinator zu finden. Die Kommunikation zwischen Spielern immer ausschließlich Mittels eines Koordinators statt. 

Triebel, Guthier und Effelsberg schlagen in \cite{triebel07g} den Einsatz vom propriäteren Skype Protokoll vor, um Spieledaten auszutauschen. Dazu unterteilen sie die Spielewelt in mehrere Regionen denen Spieler angehören können. Aktionen der Spieler in der gleichen Region, werden ebenfalls nur Spieler der gleichen Region weitergeleitet.
Dabei wird für jede Region mit Hilfe der Skype Chatraum Funktion festgehalten welche Spieler dieser Region angehören. In einer Evaluation des Verfahrens erreichen sie durchgehen akzeptable Latenzen unter 300ms, die zeigen dass der Einsatz von Skype für skalierbare Mehrspieler Spiele möglich ist. 

\subsection{Hybride P2P-Systeme}
In Hybriden Systemen werden beide Methoden gleichzeitig eingesetzt, so werden Vorteile von strukturieren Overlays wie DHT mit denen von unstrukturierten P2P Architekturen verbunden. Zunächst bestimmt ein Knoten seine Nachbarn mit Hilfe des Koordinators. Diese kontaktiert direkt ohne die Hilfe des Koordinators.  

Im strukturierten Teil des Hybriden Ansatzes von Yu \cite{yu05} werden Knoten in Master, Slave und Home knoten unterteilt, bei denen Regionen mittels der Master-Knoten verwaltet werden. Mittels der ihrer Home-Knoten Masterknoten sich untereinander verbinden und Slave-Knoten von  ihren Masterknoten verwaltet werden. Im Unstrukturieren Teil tauschen die die Master-Knoten untereinander Mittels Listen Informationen über ihre Nachbarn untereinander aus. Das System versucht so einerseits eine Partitionierung des Netzwerks zu verhindern, während der zusätzliche Netzwerkverkehr der durch die Verwendung von DHT entsteht Minimiert werden soll.

%TODO TABLE

\section{Hybride Systeme}
Hybride P2P Systeme benutzen einen zentralisierten Server um einen bestimmten Knoten der einen Service anbietet zu lokalisieren. Der Service selbst wiederum, findet direkt zwischen den Knoten statt. Das beste Beispiel eines hybriden P2P Systems sind online Dateitauschdienste wie z.B. das Torrent Protokoll. Jeder Knoten veröffentlicht seine eine Liste seiner Dateien an einen zentralen öffentlichen Server. Ein Benutzer der nach einer speziellen Datei sucht, kontaktiert zunächst den öffentlichen Server um den Knoten herauszufinden, der Dateiaustausch selbst findet zwischen den einzelnen Knoten statt. Ein anderes Beispiel ist das SIP Protokoll zur Internet-Telefonie in dem einzelne öffentliche Server die Lokalisierung und Verwaltung der Benutzer vornehmen, das Telefongespräch selbst, aber zwischen den Knoten selbst stattfindet.

\section{Peer-to-Peer SIP}
\subsection{Motivation für Peer-to-Peer SIP}
Da SIP bereits als Standard etabliert ist hat auf dem Technologien Aufsetzen können und viele Eigenschaften besitzt die es Attraktiv für einen reinen Peer-to-Peer Betrieb attraktiv machen, bestehen seit dem Jahr 2005 Bemühungen das Hybride SIP Protokoll komplett zu einem reinen Peer-to-Peer Protokoll zu erweitern. Dabei ist das Interesse sehr hoch, da Mittlerweile bereits über zwei dutzend Entwürfe zur Realisierung eines Standards bei der IETF eingegangen sind \cite{bryan07}. Der große Vorteil gegenüber anderen Systemen ist die Kombination von bereits etablierten Standards wie dem SIP und SIMPLE Protokoll \cite{rosenberg02} für Voice Over IP und Instant Messaging mit Eigenschaften von Distributed Hash Tables. Dadurch dass disher in P2P Systemen noch keine Standards existieren bietet sich die Verwendung von SIP, das als ausgereift und etabliert gilt für diese Verwendung an. Zusätzlich sind viele Endgeräte wie Firewalls und Router bereits in der Lage SIP Netzwerkverkehr zu erkennen und zu unterstützen. 

SIP ist konventionell so gestaltet, dass so viel Funktionalität wie möglich in den Endpunkten enthalten ist. So werden alle Nachrichten die für den Aufbau eines Telefongesprächs, oder dem Austausch von Nachrichten notwendig sind bereits nur zwischen nur zwischen den Endpunkten ausgetauscht. Das Verhandeln des Mediacodecs und der Fähigkeiten der einzelnen User Agents findet ebenfalls direkt zwischen den Endpunkten statt. Ist ein Telefongespräch etabliert, so fließen die Daten zwischen direkt zwischen den Teilnehmern, zwei UA können auch so konfiguriert werden, dass sie direkt miteinander völlig ohne Server kommunizieren.
Der einzige zentralisierte Baustein in SIP besteht aus der Lokation der Ressourcen, Registrar genannt. In einer gewöhnlichen SIP Konfiguration meldet sich jeder Endpunkt bei einem Registrar an der eine Zuordnung zwischen dem Namen des Teilnehmers und seiner IP Adresse herstellt. Möchte nun ein Benutzer einen anderen Anrufen so kontaktiert er zunächst den SIP Proxy um die Zieladresse herauszufinden. Dabei sind gewöhnlich Proxy und Registrar als eine Einheit vorhanden, die auch SIP Server genannt wird. 

\subsection{Funktionsweise}
Als Peer-to-Peer SIP kann verstanden werden, dass die einzige zentrale Komponente des Systems entfernt wird und dezentral zwischen den einzelnen Teilnehmern verteilt realisiert wird. Dazu müssten die einzelnen Knoten die Funktion des Registrars übernehmen. Dabei fungiert jedes Telefon als ein Knoten im Overlay. Dem Telefon wir eine PeerID zugewiesen, die ein eindeutiger Hash aus seiner IP Adresse sein kann. Der Name des Benutzers des Telefons wird ebenfalls als ein eindeutiger Hash in der ResourceID gespeichert. Dabei ist jeder Knoten für die Speicherung eines Teils der gesammten Information zuständig. 

Im Fall von DHT wird nun eine Nachricht an den Knoten mit der geringsten Entferung der PeerID zur RessourceID weitergeleitet aus einer Liste von bekannten Knoten weitergeleitet. Dieses Verfahren wird so lange wiederholt bis es beim Knoten mit der geringsten Enterfnung endet. 

Möchte ein Telefon dem Overlay beitreten so ermittelt es seine PeerID und versucht nun durch Austausch von Nachrichten seinen Platz im Overlay zu bestimmen. Wird es teil des Overlay so wird es auch für einen Teil der Informationen verantwortlich, dabei übernimmt es Informationen vom Knoten der bisher für den Lokalisationsraum zuständig war. Als nächstes wird aus dem Namen des Teilnehmers eine RessourceID gebildet. In einer Nachricht die die RessourceID und den Namen des Teilnehmers beinhaltet registriert sich der Knoten nun am Netz. Im konventionellen SIP würde diese Nachricht an einen zentralen Server weitergeleitet werden, hier jedoch wird die Nachricht so lange vom Overlay weitergeleitet bis sie ihren Zielort erreicht, wo sie von einem Knoten gespeichert wird. 

Möchte ein Benuter nun einen anderen Benutzer anrufen so wird eine Suchanfrage die die RessourcenID beinhaltet an das Overlay gestellt, diese wird durch das Netz geleitet bis der Knoten gefunden wird der die entsprechende IP Adresse enthält. Dieser Knoten beantwortet die Anfrage und der Benutzer kann nun direkt Mittels SIP direkt mit dem Zielknoten kommunizieren. 

Verlassen Knoten das Overlay so müssen sie ihre Information an andere Knoten weitergeben, oft wird die Information auch mehrfach repliziert um Datenverlust zu vermeiden. 
%TODO Graphics 

Bryan, Lowekamp und Jennings schlagen im SOSIMPLE Prototyp eine Kombination vom SIP und SIMPLE Protokoll vor in dem Knoten mittels eines auf Chord basierten DHT \cite{bryan05s} in einem Overlay verwaltet werden. Dabei sind alle Nachrichten die benötigt werden um das DHT aufrechzuerhalten, Benutzer zu Registrieren, Ressourcen zu lokalisieren, Sitzungen zu verwalten reine SIP Nachrichten. Dadurch das SIP als generisches Protokoll entworfen wurde müssen keine neuen Methoden hinzugefügt werden sondern die Nachrichtentypen um zusätzliche Header ergänzt werden. 

Alternativ analysieren Singh und Schulzrinne verschiedene VoiP Peer-to-Peer Alternativen und schlagen ebenfalls ein Konzept für P2P basierte SIP Telefonie auf Basis eines Chord basierten DHT vor \cite{schulzrinne05}.


\subsection{Architektur Variationen}
Es bestehen drei alternative Architektur Möglichkeiten im Einsatz mit DHT. 

% TODO BILD.

Wir können den DHT auf eine Server Farm limitieren, in der jeder Teilnehmer zu einem der Server verbindet. Die Server selbst implementieren eine skalierbare Datenstruktur wie DHT um den entsprechenden Eintrag zu finden. Diese Architektur ist jedoch immer noch Client Server basiert. Der Teilnehmer muss mindestens einen Server finden und zu ihm verbinden. Diese Option beinhaltet keine Modifizierung der Clients, bietet aber eine zuverlässige Server Farm Architektur. 

Eine andere Möglichkeit ist dass jeder Client auch als Server arbeitet. Das Problem hierbei ist dass nicht alle Knoten eine gleiche Verfügbarkeit und Bandbreiten Kapazität besitzen. Ein Knoten mit geringer Bandbreite und einer schlechten Anbindung z.B. hinter einer NAT besitzt eventuell nicht ausreichend im DHT funktionieren. 

Im dritten Ansatz kann eine Mischung aus den zwei Ansätzen gewählt werden in der Knoten mit hoher Kapazität  (Bandbreite, CPU, Speicher) und Verfügbarkeit (öffentlich Erreichbar) zu SuperNodes (Koordinatoren) erkoren werden. Diese Koordinatoren Formieren die DHT. Dabei entscheidet jeder Knoten aufgrund seiner Eigenschaften selbst ob eine SuperNode werden will oder nicht. 